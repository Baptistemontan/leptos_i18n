<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="02_getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="setting_up/index.html"><strong aria-hidden="true">3.</strong> Setting Up</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setting_up/01_configuration.html"><strong aria-hidden="true">3.1.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="setting_up/02_file_structure.html"><strong aria-hidden="true">3.2.</strong> File structure</a></li><li class="chapter-item expanded "><a href="setting_up/03_namespaces.html"><strong aria-hidden="true">3.3.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="setting_up/04_inheritance.html"><strong aria-hidden="true">3.4.</strong> Inheritance</a></li></ol></li><li class="chapter-item expanded "><a href="declare/index.html"><strong aria-hidden="true">4.</strong> Declare Translations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="declare/01_key_value.html"><strong aria-hidden="true">4.1.</strong> Key-Value Pairs</a></li><li class="chapter-item expanded "><a href="declare/02_interpolation.html"><strong aria-hidden="true">4.2.</strong> Interpolation</a></li><li class="chapter-item expanded "><a href="declare/03_plurals.html"><strong aria-hidden="true">4.3.</strong> Plurals</a></li><li class="chapter-item expanded "><a href="declare/04_ranges.html"><strong aria-hidden="true">4.4.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="declare/05_subkeys.html"><strong aria-hidden="true">4.5.</strong> Subkeys</a></li><li class="chapter-item expanded "><a href="declare/06_foreign_keys.html"><strong aria-hidden="true">4.6.</strong> Foreign keys</a></li><li class="chapter-item expanded "><a href="declare/07_mix_kinds.html"><strong aria-hidden="true">4.7.</strong> Mixing Kinds</a></li><li class="chapter-item expanded "><a href="declare/08_formatters.html"><strong aria-hidden="true">4.8.</strong> Formatters</a></li></ol></li><li class="chapter-item expanded "><a href="usage/index.html"><strong aria-hidden="true">5.</strong> Use Translations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/01_load.html"><strong aria-hidden="true">5.1.</strong> Load The Translations</a></li><li class="chapter-item expanded "><a href="usage/02_context.html"><strong aria-hidden="true">5.2.</strong> I18nContext</a></li><li class="chapter-item expanded "><a href="usage/03_subcontext.html"><strong aria-hidden="true">5.3.</strong> Sub-context</a></li><li class="chapter-item expanded "><a href="usage/04_t_macro.html"><strong aria-hidden="true">5.4.</strong> t! Macro</a></li><li class="chapter-item expanded "><a href="usage/05_td_macro.html"><strong aria-hidden="true">5.5.</strong> td! Macro</a></li><li class="chapter-item expanded "><a href="usage/06_td_string_macro.html"><strong aria-hidden="true">5.6.</strong> td_string! Macro</a></li><li class="chapter-item expanded "><a href="usage/07_router.html"><strong aria-hidden="true">5.7.</strong> I18nRoute</a></li><li class="chapter-item expanded "><a href="usage/08_scoping.html"><strong aria-hidden="true">5.8.</strong> Scoping</a></li><li class="chapter-item expanded "><a href="usage/09_t_format.html"><strong aria-hidden="true">5.9.</strong> t_format!</a></li><li class="chapter-item expanded "><a href="usage/10_t_plural.html"><strong aria-hidden="true">5.10.</strong> t_plural!</a></li><li class="chapter-item expanded "><a href="usage/11_const_access.html"><strong aria-hidden="true">5.11.</strong> Constant Access</a></li><li class="chapter-item expanded "><a href="usage/12_serverfn.html"><strong aria-hidden="true">5.12.</strong> Server functions</a></li></ol></li><li class="chapter-item expanded "><a href="infos/index.html"><strong aria-hidden="true">6.</strong> More Informations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="infos/01_locale_resol.html"><strong aria-hidden="true">6.1.</strong> Locale Resolution</a></li></ol></li><li class="chapter-item expanded "><a href="reduce_size/index.html"><strong aria-hidden="true">7.</strong> Reduce Binary Size</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reduce_size/01_datagen.html"><strong aria-hidden="true">7.1.</strong> ICU4X Datagen</a></li><li class="chapter-item expanded "><a href="reduce_size/02_dynamic_load.html"><strong aria-hidden="true">7.2.</strong> Lazy Load The Translations</a></li></ol></li><li class="chapter-item expanded "><a href="06_features.html"><strong aria-hidden="true">8.</strong> Features</a></li><li class="chapter-item expanded "><a href="appendix_i18n_ally.html"><strong aria-hidden="true">9.</strong> Appendix: i18n Ally extension for VSC</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is intended as an introduction to the <a href="https://github.com/Baptistemontan/leptos_i18n">Leptos_i18n</a> crate.</p>
<p>This crate is made to simplify Internationalization in a <a href="https://crates.io/crates/leptos">Leptos</a> application that loads locales at <strong><em>compile time</em></strong> and provides compile-time checks for translation keys, interpolation keys, and the selected locale.</p>
<p>This guide does assume you know some basics about <code>Leptos</code>, but the majority of the guide is about declaring the translations and how to use them. You can find the <code>Leptos</code> book <a href="https://leptos-rs.github.io/leptos/">here</a>.</p>
<blockquote>
<p>The source code for the book is available <a href="https://github.com/Baptistemontan/leptos_i18n/tree/main/docs/book">here</a>. PRs for typos or clarification are always welcome.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>First thing we need is a <code>Leptos</code> project, you can find documentation on how to set one up in the <code>Leptos</code> <a href="https://leptos-rs.github.io/leptos/02_getting_started.html">book</a>.</p>
<p>Once you have set one up, you can add this crate to your project with</p>
<pre><code class="language-bash">cargo add leptos_i18n
</code></pre>
<p>Or by adding this line to your <code>Cargo.toml</code> under <code>[dependencies]</code>:</p>
<pre><code class="language-toml">leptos_i18n = &quot;0.4&quot;
</code></pre>
<h2 id="actix-web-backend"><a class="header" href="#actix-web-backend"><code>actix-web</code> Backend</a></h2>
<p>When compiling for the backend using <code>actix-web</code>, enable the <code>actix</code> feature:</p>
<pre><code class="language-toml"># Cargo.toml

[features]
ssr = [
    &quot;leptos_i18n/actix&quot;,
]
</code></pre>
<h2 id="axum-backend"><a class="header" href="#axum-backend"><code>axum</code> Backend</a></h2>
<p>When compiling for the backend using <code>axum</code>, enable the <code>axum</code> feature:</p>
<pre><code class="language-toml"># Cargo.toml

[features]
ssr = [
    &quot;leptos_i18n/axum&quot;,
]
</code></pre>
<h2 id="hydrate"><a class="header" href="#hydrate">Hydrate</a></h2>
<p>When compiling for the client, enable the <code>hydrate</code> feature:</p>
<pre><code class="language-toml"># Cargo.toml

[features]
hydrate = [
    &quot;leptos_i18n/hydrate&quot;,
]
</code></pre>
<h2 id="client-side-rendering"><a class="header" href="#client-side-rendering">Client Side Rendering</a></h2>
<p>When compiling for the client, enable the <code>csr</code> feature:</p>
<pre><code class="language-toml"># Cargo.toml

[dependencies.leptos_i18n]
features = [&quot;csr&quot;]
</code></pre>
<p>You can find examples using CSR on the <a href="https://github.com/Baptistemontan/leptos_i18n/tree/master/examples/csr">github repo</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up"><a class="header" href="#setting-up">Setting Up</a></h1>
<p>This first section will introduce you to the configuration you need to use <code>leptos_i18n</code>. By the end of this section, you should be able to
set up the basics to start using translations in your <code>Leptos</code> application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>This crate is basically entirely based around one macro: the <code>load_locales!</code> macro. We will cover it in a later chapter, but for now just know that it looks at your translation files and generates code for them.</p>
<p>To load those translations it first needs to know what to look for, so you need to declare what locales you are supporting and which one is the default.
To do that you use the <code>[package.metadata.leptos-i18n]</code> section in your <code>Cargo.toml</code>.</p>
<p>To declare <code>en</code> and <code>fr</code> as locales, with <code>en</code> being the default you would write:</p>
<pre><code class="language-toml">[package.metadata.leptos-i18n]
default = &quot;en&quot;
locales = [&quot;en&quot;, &quot;fr&quot;]
</code></pre>
<p>There are more optional values you can supply:</p>
<ul>
<li><code>namespaces</code>: This is to split your translations into multiple files, we will cover it in a later chapter</li>
<li><code>locales-dir</code>: This is to have a custom path to the directory containing the locales files, it defaults to <code>&quot;./locales&quot;</code>.</li>
<li><code>translations-path</code>: Used in a CSR application with the <code>dynamic_load</code> feature, more information in a later chapter.</li>
<li><code>inherits</code>: Allow to describe inheritance structure for locales, covered in a later chapter.</li>
</ul>
<p>Once this configuration is done, you can start writing your translations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h1>
<p>Now that you have configured your locales, you can start writing your translations. This chapter covers where to put your files. We will cover how to write them in another section.</p>
<p>By default, you must put your files in the <code>./locales</code> directory, and each file must be <code>%{locale}.json</code>:</p>
<pre><code class="language-bash">./locales
├── en.json
└── fr.json
</code></pre>
<h2 id="custom-directory"><a class="header" href="#custom-directory">Custom Directory</a></h2>
<p>You can change the path to the directory containing the files with the <code>locales-dir</code> field in the configuration, for example:</p>
<pre><code class="language-toml">[package.metadata.leptos-i18n]
default = &quot;en&quot;
locales = [&quot;en&quot;, &quot;fr&quot;]
locales-dir = &quot;./path/to/mylocales”
</code></pre>
<p>will look for:</p>
<pre><code class="language-bash">./path
└── to
    └── mylocales
        ├── en.json
        └── fr.json
</code></pre>
<h2 id="other-formats"><a class="header" href="#other-formats">Other Formats</a></h2>
<p>JSON being the default, you can change that by first removing the default features and enabling the feature for the format you need:</p>
<pre><code class="language-toml"># Cargo.toml

[dependencies]
leptos_i18n = {
    default-features = false,
    features = [&quot;yaml_files&quot;]
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Feature</th></tr></thead><tbody>
<tr><td>JSON (default)</td><td><code>json_files</code></td></tr>
<tr><td>YAML</td><td><code>yaml_files</code></td></tr>
</tbody></table>
</div>
<p>Other formats may be supported later.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<p>Translations files can grow quite rapidly and become very big, and avoiding key collisions can be hard without avoiding long names.
To avoid this situation, you can declare namespaces in the configuration:</p>
<pre><code class="language-toml">[package.metadata.leptos-i18n]
default = &quot;en&quot;
locales = [&quot;en&quot;, &quot;fr&quot;]
namespaces = [&quot;common&quot;, &quot;home&quot;]
</code></pre>
<p>Then your file structures must look like this in the <code>/locales</code> directory:</p>
<pre><code class="language-bash">./locales
├── en
│   ├── common.json
│   └── home.json
└── fr
    ├── common.json
    └── home.json
</code></pre>
<p>You can now make smaller files, with one for each section of the website, for example.
This also allows the <code>common</code> namespace to use keys that the <code>home</code> namespace also uses, without colliding.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extanding-a-locale"><a class="header" href="#extanding-a-locale">Extanding a locale</a></h1>
<p>The <code>inherits</code> config options under the <code>[package.metadata.leptos-i18n]</code> can allow you to describe inheritance hierarchy for your locales:</p>
<pre><code class="language-toml">[package.metadata.leptos-i18n]
default = &quot;en&quot;
locales = [&quot;en&quot;, &quot;fr&quot;, &quot;fr-CA&quot;]
inherits = { fr-CA = &quot;fr&quot; }
</code></pre>
<p>This will default any missing keys in &quot;fr-CA&quot; to the value in &quot;fr&quot;.</p>
<p>The &quot;general&quot; default for missing keys will still be the default locale, so if a key is missing in both &quot;fr&quot; and &quot;fr-CA&quot;, the key will use the value in &quot;en&quot;.</p>
<h2 id="recursive-inheritance"><a class="header" href="#recursive-inheritance">Recursive inheritance</a></h2>
<p>You can have recursive inheritances, this is allowed and works as expected:</p>
<pre><code class="language-toml">[package.metadata.leptos-i18n]
default = &quot;en&quot;
locales = [&quot;en&quot;, &quot;fr&quot;, &quot;fr-CA&quot;, &quot;fr-FR&quot;]
inherits = { fr-CA = &quot;fr-FR&quot;, fr-FR = &quot;fr&quot; }
</code></pre>
<blockquote>
<p>note: cyclic inheritance is also valid but I don't see the use, it's only supported because if we didn't detected cycles we could have an endless loop when resolving what default to use, if a cycle is encountered on a missing key the default locale is used.</p>
</blockquote>
<h2 id="missing-key-warnings"><a class="header" href="#missing-key-warnings">Missing key warnings</a></h2>
<p>if locale A extend locale B, missing key warnings will not be emitted for locale A.</p>
<p>Explicitly setting the inheritance to the default locale is also a way to suppress missing key warnings for a given locale:</p>
<pre><code class="language-toml">[package.metadata.leptos-i18n]
default = &quot;en&quot;
locales = [&quot;en&quot;, &quot;fr&quot;, &quot;it&quot;]
inherits = { it = &quot;en&quot; }
</code></pre>
<p>While the above is technically already the default behavior, missing warnings will not be emitted for the &quot;it&quot; locale, but will be emitted for the &quot;fr&quot; locale.</p>
<h2 id="extends-the-default-locale"><a class="header" href="#extends-the-default-locale">Extends the default locale</a></h2>
<p>The default locale can not inherit.</p>
<p>This is not allowed and will error:</p>
<pre><code class="language-toml">[package.metadata.leptos-i18n]
default = &quot;en&quot;
locales = [&quot;en&quot;, &quot;fr&quot;]
inherits = { en = &quot;fr&quot; }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declare-translations"><a class="header" href="#declare-translations">Declare translations</a></h1>
<p>Now that we covered the configuration and where to put each file, we can now start writing the translations.
This chapter covers this topic only for the <code>JSON</code> format.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-value-pairs"><a class="header" href="#key-value-pairs">Key-Value Pairs</a></h1>
<p>As expected, you declare your translations as key-value pairs:</p>
<pre><code class="language-json">{
  &quot;hello_world&quot;: &quot;Hello World!&quot;
}
</code></pre>
<p>But there are additional rules you must follow in addition to those of the format you use.</p>
<h2 id="keys"><a class="header" href="#keys">Keys</a></h2>
<p>Key names must be <a href="https://doc.rust-lang.org/reference/identifiers.html">valid Rust identifiers</a>, with the exception of <code>-</code> that would be converted to <code>_</code>, and does not support <a href="https://doc.rust-lang.org/reference/keywords.html#strict-keywords">strict</a> or <a href="https://doc.rust-lang.org/reference/keywords.html#reserved-keywords">reserved</a> keywords.</p>
<h2 id="same-keys-across-files"><a class="header" href="#same-keys-across-files">Same keys across files</a></h2>
<p>The keys must be the same across all files, else the <code>load_locales!</code> macro will emit warnings. The difference in keys is based on the default locale.</p>
<h3 id="missing-key"><a class="header" href="#missing-key">Missing key</a></h3>
<p>If a key is present in the default locale but not in another locale, the other locale will default its value to the default locale one and emit a warning that a key is missing in that locale.</p>
<p>If you want to explicitly state that this value takes the value of the default locale, you can declare it as <code>null</code>:</p>
<pre><code class="language-json">{
  &quot;take_value_of_default&quot;: null
}
</code></pre>
<p>This will no longer trigger a warning for that key.</p>
<h3 id="surplus-key"><a class="header" href="#surplus-key">Surplus key</a></h3>
<p>If a key is present in another locale but not in the default locale, this key will be ignored and a warning will be emitted.</p>
<h2 id="value-kinds"><a class="header" href="#value-kinds">Value Kinds</a></h2>
<p>You can specify multiple kinds of values:</p>
<ul>
<li>Literals (String, Numbers, Boolean)</li>
<li>Interpolated String</li>
<li>Ranges</li>
<li>Plurals</li>
</ul>
<p>The next chapters of this section will cover them, apart from literals, those are self-explanatory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interpolation"><a class="header" href="#interpolation">Interpolation</a></h1>
<h2 id="interpolate-values"><a class="header" href="#interpolate-values">Interpolate Values</a></h2>
<p>There may be situations where you must interpolate a value inside your translations, for example, a dynamic number.
You could declare 2 translations and use them with that number, but this is not an elegant solution.</p>
<p>To declare a value that will be interpolated in your translations, simply give it a name surrounded by <code>{{ }}</code>:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: &quot;You clicked {{ count }} times&quot;
}
</code></pre>
<h2 id="interpolate-components"><a class="header" href="#interpolate-components">Interpolate Components</a></h2>
<p>There may also be situations where you want to wrap part of your translation into a component, for example, to highlight it.</p>
<p>You can declare a component with HTML-like syntax:</p>
<pre><code class="language-json">{
  &quot;highlight_me&quot;: &quot;highlight &lt;b&gt;me&lt;/b&gt;&quot;
}
</code></pre>
<h2 id="use-both"><a class="header" href="#use-both">Use both</a></h2>
<p>You can mix them both without a problem:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: &quot;You clicked &lt;b&gt;{{ count }}&lt;/b&gt; times&quot;
}
</code></pre>
<h2 id="values-names"><a class="header" href="#values-names">Values Names.</a></h2>
<p>Values names must follow the same rules as <a href="declare/./01_key_value.html#keys">keys</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plurals"><a class="header" href="#plurals">Plurals</a></h1>
<h2 id="what-are-plurals-"><a class="header" href="#what-are-plurals-">What are plurals ?</a></h2>
<p>Plurals are a standardized way to deal with numbers. For example, the English language deals with 2 plurals: <em>&quot;one&quot;</em> (1) and <em>&quot;other&quot;</em> (0, 2, 3, ..).</p>
<p>If you were to have</p>
<pre><code class="language-json">{
  &quot;items&quot;: &quot;{{ count }} items&quot;
}
</code></pre>
<p>this would produce &quot;1 items&quot;, which is not good English.</p>
<p>This can be solved by defining 2 plural forms:</p>
<pre><code class="language-json">{
  &quot;items_one&quot;: &quot;{{ count }} item&quot;,
  &quot;items_other&quot;: &quot;{{ count }} items&quot;
}
</code></pre>
<p>Providing the count to the <code>t!</code> macro, this will result in:</p>
<pre><code class="language-rust ignore">let i18n = use_i18n();

t!(i18n, items, count = || 0) // -&gt; &quot;0 items&quot;
t!(i18n, items, count = || 1) // -&gt; &quot;1 item&quot;
t!(i18n, items, count = || 4) // -&gt; &quot;4 items&quot;</code></pre>
<blockquote>
<p>All <code>items_*</code> are merged into the single key <code>items</code>.</p>
</blockquote>
<p><code>{{ count }}</code> is a special variable when using plurals. Even if you don't interpolate it, you must supply it:</p>
<pre><code class="language-json">{
  &quot;items_one&quot;: &quot;one item&quot;,
  &quot;items_other&quot;: &quot;some items&quot;
}
</code></pre>
<p>This will still need you to supply the <code>count</code> variable: <code>t!(i18n, items, count = ...)</code>.</p>
<h2 id="why-bother-"><a class="header" href="#why-bother-">Why bother ?</a></h2>
<p>Why bother and not just do</p>
<pre><code class="language-rust ignore">if item_count == 1 {
    t!(i18n, items_one)
} else {
    t!(i18n, items_other, count = move || item_count)
}</code></pre>
<p>Because all languages don't use the same plurals!</p>
<p>For example, in French, 0 is considered singular, so this could produce &quot;0 choses&quot; instead of &quot;0 chose&quot;, which is bad French (except in certain conditions, because French, exceptions are everywhere).</p>
<h2 id="ordinal-plurals"><a class="header" href="#ordinal-plurals">Ordinal plurals</a></h2>
<p>What I describe above are &quot;Cardinal&quot; plurals, but they don't work with like &quot;1st place&quot;, &quot;2nd place&quot;, etc.</p>
<p>The English language uses 4 ordinal plurals, and French 2:</p>
<ul>
<li>one: &quot;1st place&quot;, &quot;21st place&quot;</li>
<li>two: &quot;2nd place&quot;, &quot;22nd place&quot;</li>
<li>few: &quot;3rd place&quot;, &quot;33rd place&quot;</li>
<li>other: &quot;4th place&quot;, &quot;5th place&quot;, &quot;7th place&quot;</li>
</ul>
<p>And French:</p>
<ul>
<li>one: &quot;1ère place&quot;</li>
<li>other: &quot;2ème place&quot;, &quot;21ème place&quot;</li>
</ul>
<p>You can use them by using the <code>_ordinal</code> suffix:</p>
<pre><code class="language-json">{
  &quot;key_ordinal_one&quot;: &quot;{{ count }}st place&quot;,
  &quot;key_ordinal_two&quot;: &quot;{{ count }}nd place&quot;,
  &quot;key_ordinal_few&quot;: &quot;{{ count }}rd place&quot;,
  &quot;key_ordinal_other&quot;: &quot;{{ count }}th place&quot;
}
</code></pre>
<blockquote>
<p>The <code>_ordinal</code> suffix is removed, in this example you access it with <code>t!(i18n, key, count = ..)</code></p>
</blockquote>
<h2 id="how-to-know-which-to-use"><a class="header" href="#how-to-know-which-to-use">How to know which to use:</a></h2>
<p>There are resources online to help you find what you should use, my personal favorite is the <a href="https://www.unicode.org/cldr/charts/44/supplemental/language_plural_rules.html">Unicode CLDR Charts</a>.</p>
<h2 id="what-if-i-need-multiple-counts-"><a class="header" href="#what-if-i-need-multiple-counts-">What if I need multiple counts ?</a></h2>
<p>If you need multiple counts, for example:</p>
<pre><code class="language-json">{
  &quot;key&quot;: &quot;{{ boys_count }} boys and {{ girls_count }} girls&quot;
}
</code></pre>
<p>There isn't a way to represent this in a single key, you will need <code>Foreign keys</code> that you can read about in a next chapter.</p>
<h2 id="activate-the-feature"><a class="header" href="#activate-the-feature">Activate the feature</a></h2>
<p>To use plurals in your translations, enable the &quot;plurals&quot; feature.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ranges"><a class="header" href="#ranges">Ranges</a></h1>
<p>We just talked about plurals, which are standardized, but we have a little unorthodox feature that I called ranges.</p>
<p>They are based around a count and display different translations based on this count.</p>
<p>To declare them, the key takes a sequence where each element is a sequence with the first element being the value, and the other element the count to match against:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;You have not clicked yet&quot;, 0],
    [&quot;You clicked once&quot;, 1],
    [&quot;You clicked {{ count }} times&quot;, &quot;_&quot;]
  ]
}
</code></pre>
<h2 id="multiple-exact-values"><a class="header" href="#multiple-exact-values">Multiple exact values</a></h2>
<p>You can declare multiple counts to match against:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;0 or 5&quot;, 0, 5],
    [&quot;1, 2, 3 or 4&quot;, 1, 2, 3, 4],
    [&quot;You clicked {{ count }} times&quot;, &quot;_&quot;]
  ]
}
</code></pre>
<h2 id="ranges-1"><a class="header" href="#ranges-1">Ranges</a></h2>
<p>You can also declare a range where the translations are used:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;0 or 5&quot;, 0, 5],
    [&quot;1, 2, 3 or 4&quot;, &quot;1..=4&quot;],
    [&quot;You clicked {{ count }} times&quot;, &quot;_&quot;]
  ]
}
</code></pre>
<p>You can use all Rust ranges syntax: <code>s..e</code>, <code>..e</code>, <code>s..</code>, <code>s..=e</code>, <code>..=e</code> or even <code>..</code> ( <code>..</code> will be considered fallback <code>_</code>).</p>
<h2 id="number-type"><a class="header" href="#number-type">Number type</a></h2>
<p>By default, the count is expected to be an <code>i32</code>, but you can change that by specifying the type as the first element of the sequence:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    &quot;u32&quot;,
    [&quot;You have not clicked yet&quot;, 0],
    [&quot;You clicked once&quot;, 1],
    [&quot;You clicked {{ count }} times&quot;, &quot;_&quot;]
  ]
}
</code></pre>
<p>Now you only have to cover the <code>u32</code> range.</p>
<p>The supported types are <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>f32</code>, and <code>f64</code>.</p>
<h2 id="fallback"><a class="header" href="#fallback">Fallback</a></h2>
<p>If all the given counts don't fill the range of the number type, you can use a fallback (<code>&quot;_&quot;</code> or <code>&quot;..&quot;</code>) as seen above, but it can be completely omitted on the last element of the sequence:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;You have not clicked yet&quot;, 0],
    [&quot;You clicked once&quot;, 1],
    [&quot;You clicked {{ count }} times&quot;]
  ]
}
</code></pre>
<p>Fallbacks are not required if you already cover the full number range:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    &quot;u8&quot;,
    [&quot;You have not clicked yet&quot;, 0],
    [&quot;1 to 254&quot;, &quot;1..=254&quot;],
    [&quot;255&quot;, 255]
  ]
}
</code></pre>
<p>Fallbacks are always required for <code>f32</code> and <code>f64</code>.</p>
<h2 id="order"><a class="header" href="#order">Order</a></h2>
<p>The order of the ranges matters, for example:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;first&quot;, &quot;0..5&quot;],
    [&quot;second&quot;, &quot;0..=5&quot;],
    [&quot;You clicked {{ count }} times&quot;]
  ]
}
</code></pre>
<p>Here &quot;second&quot; will only be printed if count is 5, if <code>0 &lt;= count &lt; 5</code> then &quot;first&quot; will be printed.</p>
<h2 id="mix-ranges-with-exact-values"><a class="header" href="#mix-ranges-with-exact-values">Mix ranges with exact values</a></h2>
<p>You can totally mix them, this is valid:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;first&quot;, 0, &quot;3..5&quot;, &quot;10..=56&quot;],
    [&quot;second&quot;, &quot;0..3&quot;, &quot;..78&quot;],
    [&quot;You clicked {{ count }} times&quot;]
  ]
}
</code></pre>
<h2 id="use-interpolation"><a class="header" href="#use-interpolation">Use interpolation</a></h2>
<p>The &quot;You clicked {{ count }} times&quot; kind of gave it away, but you can use interpolation in your ranges, this is valid:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;&lt;b&gt;first&lt;/b&gt;&quot;, 0, &quot;3..5&quot;, &quot;10..=56&quot;],
    [&quot;&lt;i&gt;second&lt;/i&gt;&quot;, &quot;0..3&quot;, &quot;..78&quot;],
    [&quot;You clicked {{ count }} times and have {{ banana_count }} bananas&quot;]
  ]
}
</code></pre>
<p>With ranges, <code>{{ count }}</code> is a special variable that refers to the count provided to the range, so you don't need to also provide it:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;You have not clicked yet&quot;, 0],
    [&quot;You clicked once&quot;, 1],
    [&quot;You clicked {{ count }} times&quot;]
  ]
}
</code></pre>
<pre><code class="language-rust ignore">t!(i18n, click_count, count = || 0);</code></pre>
<p>Will result in <code>&quot;You have not clicked yet&quot;</code> and</p>
<pre><code class="language-rust ignore">t!(i18n, click_count, count = || 5);</code></pre>
<p>Will result in <code>&quot;You clicked 5 times&quot;</code>.</p>
<p>Providing <code>count</code> will create an error:</p>
<pre><code class="language-rust ignore">t!(i18n, click_count, count = 12, count = || 5); // compilation error</code></pre>
<h2 id="what-if-i-need-multiple-counts--1"><a class="header" href="#what-if-i-need-multiple-counts--1">What if I need multiple counts ?</a></h2>
<p>If you need multiple counts, for example:</p>
<pre><code class="language-json">{
  &quot;key&quot;: &quot;{{ boys_count }} boys and {{ girls_count }} girls&quot;
}
</code></pre>
<p>There isn't a way to represent this in a single key. You will need <code>Foreign keys</code> that you can read about in a future chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subkeys"><a class="header" href="#subkeys">Subkeys</a></h1>
<p>You can declare subkeys by just giving a map to the key:</p>
<pre><code class="language-json">{
  &quot;subkeys&quot;: {
    &quot;subkey_1&quot;: &quot;This is subkey_1&quot;,
    &quot;subkey_n&quot;: &quot;This is subkey &lt;b&gt;{{ n }}&lt;/b&gt;&quot;,
    &quot;nested_subkeys&quot;: {
      &quot;nested_subkey_1&quot;: &quot;you can nest subkeys&quot;
    }
  }
}
</code></pre>
<pre><code class="language-rust ignore">t!(i18n, subkeys.subkey_1); // -&gt; &quot;This is subkey_1&quot;
t!(i18n, subkeys.nested_subkeys.nested_subkey_1) // -&gt; &quot;you can nest subkeys&quot;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-keys"><a class="header" href="#foreign-keys">Foreign keys</a></h1>
<p>Foreign keys let you re-use already declared translations:</p>
<pre><code class="language-json">{
  &quot;hello_world&quot;: &quot;Hello World!&quot;,
  &quot;reuse&quot;: &quot;message: $t(hello_world)&quot;
}
</code></pre>
<p>This will replace <code>$t(hello_world)</code> by the value of the key <code>hello_world</code>, making <code>reuse</code> equal to <code>&quot;message: Hello World!&quot;</code>.</p>
<p>You can point to any key other than ranges and keys containing subkeys.</p>
<p>To point to subkeys, you give the path by separating the key by <code>.</code>: <code>$t(key.subkey.subsubkey)</code>.</p>
<p>When using namespaces, you <em>must</em> specify the namespace of the key you are looking for, using <code>:</code>: <code>$t(namespace:key)</code>.</p>
<p>You can point to explicitly defaulted keys, but not implicitly defaulted ones.</p>
<h2 id="supply-arguments"><a class="header" href="#supply-arguments">Supply arguments</a></h2>
<p>You can also supply arguments to fill variables of the pointed key:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: &quot;You clicked {{ count }} times&quot;,
  &quot;clicked_twice&quot;: &quot;$t(click_count, {\&quot;count\&quot;: \&quot;two\&quot;})&quot;
}
</code></pre>
<p>This will result in <code>clicked_twice</code> to have the value <code>&quot;You clicked two times&quot;</code>.</p>
<p>Arguments must be strings, delimited by either single quotes or double quotes.</p>
<blockquote>
<p><strong>Note</strong>: Any argument with no matching variable is just discarded; they will not emit any warning/error.</p>
</blockquote>
<p>Arguments can be anything that could be parsed as a normal key-value:</p>
<pre><code class="language-json">{
  &quot;key&quot;: &quot;{{ arg }}&quot;,
  &quot;string_arg&quot;: &quot;$t(key, {\&quot;arg\&quot;: \&quot;str\&quot;})&quot;,
  &quot;boolean_arg&quot;: &quot;$t(key, {\&quot;arg\&quot;: true})&quot;,
  &quot;number_arg&quot;: &quot;$t(key, {\&quot;arg\&quot;: 56})&quot;,
  &quot;interpolated_arg&quot;: &quot;$t(key, {\&quot;arg\&quot;: \&quot;value: {{ new_arg }}\&quot;})&quot;,
  &quot;foreign_key_arg&quot;: &quot;$t(key, {\&quot;arg\&quot;: \&quot;value: $t(interpolated_arg)\&quot;})&quot;
}
</code></pre>
<pre><code class="language-rust ignore">t!(i18n, string_arg); // -&gt; &quot;str&quot;
t!(i18n, boolean_arg); // -&gt; &quot;true&quot;
t!(i18n, number_arg); // -&gt; &quot;56&quot;
t!(i18n, interpolated_arg, new_arg = &quot;a value&quot;); // -&gt; &quot;value: a value&quot;
t!(i18n, foreign_key_arg, new_arg = &quot;a value&quot;); // -&gt; &quot;value: value: a value&quot;</code></pre>
<h2 id="count-arg-for-pluralsranges"><a class="header" href="#count-arg-for-pluralsranges"><code>&quot;count&quot;</code> arg for plurals/ranges</a></h2>
<p>If you have a plural like</p>
<pre><code class="language-json">{
  &quot;key_one&quot;: &quot;one item&quot;,
  &quot;key_other&quot;: &quot;{{ count }} items&quot;
}
</code></pre>
<p>You can supply the count as a foreign key in 2 ways, as a variable:</p>
<pre><code class="language-json">{
  &quot;new_key&quot;: &quot;$t(key, {\&quot;count\&quot;: \&quot;{{ new_count }}\&quot;})&quot;
}
</code></pre>
<p>This will just rename the key.</p>
<pre><code class="language-rust ignore">t!(i18n, new_key, new_count = move || 1); // -&gt; &quot;one item&quot;
t!(i18n, new_key, new_count = move || 2); // -&gt; &quot;2 items&quot;</code></pre>
<blockquote>
<p><strong>note</strong>: for the <code>count</code> arg to plurals/ranges, the value provided must be a single variable (whitespaces around are supported though).</p>
</blockquote>
<p>Or by an actual value:</p>
<pre><code class="language-json">{
  &quot;singular_key&quot;: &quot;$t(key, {\&quot;count\&quot;: 1})&quot;,
  &quot;multiple_key&quot;: &quot;$t(key, {\&quot;count\&quot;: 6})&quot;
}
</code></pre>
<pre><code class="language-rust ignore">t!(i18n, singular_key); // -&gt; &quot;one item&quot;
t!(i18n, multiple_key); // -&gt; &quot;6 items&quot;</code></pre>
<blockquote>
<p><strong>note</strong>: while floats are supported, they don't carry all the information once deserialized such as leading 0, so some truncation may occur.</p>
</blockquote>
<h2 id="multiple-counts-ranges-or-plurals"><a class="header" href="#multiple-counts-ranges-or-plurals">Multiple counts ranges or plurals</a></h2>
<p>If you need multiple counts for a plural or a range, for example:</p>
<pre><code class="language-json">{
  &quot;key&quot;: &quot;{{ boys_count }} boys and {{ girls_count }} girls&quot;
}
</code></pre>
<p>You can use <code>Foreign keys</code> to construct a single key from multiple plurals/ranges by overriding their <code>&quot;count&quot;</code> variable:</p>
<pre><code class="language-json">{
  &quot;key&quot;: &quot;$t(key_boys, {\&quot;count\&quot;: \&quot;{{ boys_count }}\&quot;}) and $t(key_girls, {\&quot;count\&quot;: \&quot;{{ girls_count }}\&quot;})&quot;,
  &quot;key_boys_one&quot;: &quot;{{ count }} boy&quot;,
  &quot;key_boys_other&quot;: &quot;{{ count }} boys&quot;,
  &quot;key_girls_one&quot;: &quot;{{ count }} girl&quot;,
  &quot;key_girls_other&quot;: &quot;{{ count }} girls&quot;
}
</code></pre>
<pre><code class="language-rust ignore">t!(i18n, key, boys_count = move || 0, girls_count = move || 0); // -&gt; &quot;0 boys and 0 girls&quot;
t!(i18n, key, boys_count = move || 0, girls_count = move || 1); // -&gt; &quot;0 boys and 1 girl&quot;
t!(i18n, key, boys_count = move || 1, girls_count = move || 0); // -&gt; &quot;1 boy and 0 girls&quot;
t!(i18n, key, boys_count = move || 56, girls_count = move || 39); // -&gt; &quot;56 boys and 39 girls&quot;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mixing-kinds"><a class="header" href="#mixing-kinds">Mixing Kinds</a></h1>
<p>What happens if for a key you declare ranges in one locale, interpolation in another, and a simple string in a third ?</p>
<p>Well, this is totally allowed, but you will still need to supply all values/components of every locale combined when using the translation, regardless of what the current locale is.</p>
<p>What is not allowed to mix are subkeys. If a key has subkeys in one locale, the key must have subkeys in all locales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatters"><a class="header" href="#formatters">Formatters</a></h1>
<p>For interpolation, every variables (other than <code>count</code> for ranges) are expected to be of type <code>impl IntoView + Clone + 'static</code>.</p>
<p>But some values have different ways to be represented based on the locale:</p>
<ul>
<li>Number</li>
<li>Date</li>
<li>Time</li>
<li>List</li>
</ul>
<p>You can specify the kind of value you are going to supply like this:</p>
<pre><code class="language-json">{
  &quot;key&quot;: &quot;{{ var, formatter }}&quot;
}
</code></pre>
<p>Some of the formatters can take arguments to better suits the format you need:</p>
<pre><code class="language-json">{
  &quot;key&quot;: &quot;{{ var, formatter(arg_name: value; arg_name2: value; ...) }}&quot;
}
</code></pre>
<p>If an argument has a default value, not supplying that argument will make that arg take the default value.</p>
<p>Here are all the formatters:</p>
<h2 id="number"><a class="header" href="#number">Number</a></h2>
<pre><code class="language-json">{
  &quot;number_formatter&quot;: &quot;{{ num, number }}&quot;
}
</code></pre>
<p>Will format the number based on the locale.
This makes the variable needed to be <code>impl leptos_i18n::formatting::NumberFormatterInputFn</code>, which is automatically implemented for <code>impl Fn() -&gt; T + Clone + 'static where T: leptos_i18n::formatting::IntoFixedDecimal</code>.
<code>IntoFixedDecimal</code> is a trait to turn a value into a <code>fixed_decimal::FixedDecimal</code>, which is a type used by <code>icu</code> to format numbers. That trait is currently implemented for:</p>
<ul>
<li>FixedDecimal</li>
<li>usize</li>
<li>u8</li>
<li>u16</li>
<li>u32</li>
<li>u64</li>
<li>u128</li>
<li>isize</li>
<li>i8</li>
<li>i16</li>
<li>i32</li>
<li>i64</li>
<li>i128</li>
<li>f32 *</li>
<li>f64 *</li>
</ul>
<blockquote>
<p>* Is implemented for convenience, but uses <a href="https://docs.rs/fixed_decimal/latest/fixed_decimal/struct.FixedDecimal.html#method.try_from_f64"><code>FixedDecimal::try_from_f64</code></a> with the floating precision; you may want to use your own.</p>
</blockquote>
<p>The formatter itself doesn’t provide formatting options such as maximum significant digits, but those can be customized through <code>FixedDecimal</code> before being passed to the formatter.</p>
<p>Enable the &quot;format_nums&quot; feature to use the number formatter.</p>
<h3 id="arguments"><a class="header" href="#arguments">Arguments</a></h3>
<p>There is one argument at the moment for the number formatter: <code>grouping_strategy</code>, which is based on <a href="https://docs.rs/icu_decimal/latest/icu_decimal/options/enum.GroupingStrategy.html"><code>icu::decimal::options::GroupingStrategy</code></a>, that can take 4 values:</p>
<ul>
<li>auto (default)</li>
<li>never</li>
<li>always</li>
<li>min2</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-rust ignore">use crate::i18n::*;

let i18n = use_i18n();

let num = move || 100_000;

t!(i18n, number_formatter, num);</code></pre>
<h2 id="currency-experimental"><a class="header" href="#currency-experimental">Currency (experimental)</a></h2>
<pre><code class="language-json">{
  &quot;currency_formatter&quot;: &quot;{{ num, currency }}&quot;
}
</code></pre>
<p>Will format the currency based on the locale.
The variable should be the same as <a href="declare/08_formatters.html#number">number</a>.</p>
<p>Enable the &quot;format_currency&quot; feature to use the number formatter.</p>
<h3 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h3>
<p>There are two arguments at the moment for the currency formatter: <code>width</code> and <code>currency_code</code>, which are based on <a href="https://docs.rs/icu_experimental/0.1.0/icu_experimental/dimension/currency/options/enum.Width.html"><code>icu_experimental::dimension::currency::options::Width</code></a> and <a href="https://docs.rs/icu_experimental/0.1.0/icu_experimental/dimension/currency/formatter/struct.CurrencyCode.html"><code>icu_experimental::dimension::currency::formatter::CurrencyCode</code></a>.</p>
<p><code>width</code> values:</p>
<ul>
<li>short (default)</li>
<li>narrow</li>
</ul>
<p><code>currency_code</code> value should be a <a href="https://www.iban.com/currency-codes">currency code</a>, such as USD or EUR. The USD is the default value.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-rust ignore">use crate::i18n::*;

let i18n = use_i18n();

let num = move || 100_000;

t!(i18n, currency_formatter, num);</code></pre>
<h2 id="date"><a class="header" href="#date">Date</a></h2>
<pre><code class="language-json">{
  &quot;date_formatter&quot;: &quot;{{ date_var, date }}&quot;
}
</code></pre>
<p>Will format the date based on the locale.
This makes the variable needed to be <code>impl leptos_i18n::formatting::DateFormatterInputFn</code>, which is automatically implemented for <code>impl Fn() -&gt; T + Clone + 'static where T: leptos_i18n::formatting::IntoIcuDate</code>.
<code>IntoIcuDate</code> is a trait to turn a value into a <code>impl icu::datetime::input::DateInput</code>, which is a trait used by <code>icu</code> to format dates. The <code>IntoIcuDate</code> trait is currently implemented for <code>T: DateInput&lt;Calendar = AnyCalendar&gt;</code>.
You can use <code>icu::datetime::{Date, DateTime}</code>, or implement that trait for anything you want.</p>
<p>Enable the &quot;format_datetime&quot; feature to use the date formatter.</p>
<h3 id="arguments-2"><a class="header" href="#arguments-2">Arguments</a></h3>
<p>There is one argument at the moment for the date formatter: <code>date_length</code>, which is based on <a href="https://docs.rs/icu/latest/icu/datetime/options/length/enum.Date.html"><code>icu::datetime::options::length::Date</code></a>, that can take 4 values:</p>
<ul>
<li>full</li>
<li>long</li>
<li>medium (default)</li>
<li>short</li>
</ul>
<pre><code class="language-json">{
  &quot;short_date_formatter&quot;: &quot;{{ date_var, date(date_length: short) }}&quot;
}
</code></pre>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos_i18n::reexports::icu::calendar::Date;

let i18n = use_i18n();

let date_var = move || Date::try_new_iso_date(1970, 1, 2).unwrap().to_any();

t!(i18n, date_formatter, date_var);</code></pre>
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<pre><code class="language-json">{
  &quot;time_formatter&quot;: &quot;{{ time_var, time }}&quot;
}
</code></pre>
<p>Will format the time based on the locale.
This makes the variable needed to be <code>impl leptos_i18n::formatting::TimeFormatterInputFn</code>, which is automatically implemented for <code>impl Fn() -&gt; T + Clone + 'static where T: leptos_i18n::formatting::IntoIcuTime</code>.
<code>IntoIcuTime</code> is a trait to turn a value into a <code>impl icu::datetime::input::TimeInput</code>, which is a trait used by <code>icu</code> to format time. The <code>IntoIcuTime</code> trait is currently implemented for <code>T: IsoTimeInput</code>.
You can use <code>icu::datetime::{Time, DateTime}</code>, or implement that trait for anything you want.</p>
<p>Enable the &quot;format_datetime&quot; feature to use the time formatter.</p>
<h3 id="arguments-3"><a class="header" href="#arguments-3">Arguments</a></h3>
<p>There is one argument at the moment for the time formatter: <code>time_length</code>, which is based on <a href="https://docs.rs/icu/latest/icu/datetime/options/length/enum.Time.html"><code>icu::datetime::options::length::Time</code></a>, that can take 4 values:</p>
<ul>
<li>full</li>
<li>long</li>
<li>medium</li>
<li>short (default)</li>
</ul>
<pre><code class="language-json">{
  &quot;full_time_formatter&quot;: &quot;{{ time_var, time(time_length: full) }}&quot;
}
</code></pre>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos_i18n::reexports::icu::calendar::Date;

let i18n = use_i18n();

let time_var = move || Time::try_new(14, 34, 28, 0).unwrap();

t!(i18n, time_formatter, time_var);</code></pre>
<h2 id="datetime"><a class="header" href="#datetime">DateTime</a></h2>
<pre><code class="language-json">{
  &quot;datetime_formatter&quot;: &quot;{{ datetime_var, datetime }}&quot;
}
</code></pre>
<p>Will format the datetime based on the locale.
This makes the variable needed to be <code>impl leptos_i18n::formatting::DateTimeFormatterInputFn</code>, which is automatically implemented for <code>impl Fn() -&gt; T + Clone + 'static where T: leptos_i18n::formatting::IntoIcuDateTime</code>.
<code>IntoIcuDateTime</code> is a trait to turn a value into a <code>impl icu::datetime::input::DateTimeInput</code> which is a trait used by <code>icu</code> to format datetimes. The <code>IntoIcuDateTime</code> trait is currently implemented for <code>T: DateTimeInput&lt;Calendar = AnyCalendar&gt;</code>.
You can use <code>icu::datetime::DateTime</code>, or implement that trait for anything you want.</p>
<p>Enable the &quot;format_datetime&quot; feature to use the datetime formatter.</p>
<h3 id="arguments-4"><a class="header" href="#arguments-4">Arguments</a></h3>
<p>There are two arguments at the moment for the datetime formatter: <code>date_length</code> and <code>time_length</code> that behave exactly the same as the one above.</p>
<pre><code class="language-json">{
  &quot;short_date_long_time_formatter&quot;: &quot;{{ datetime_var, datetime(date_length: short; time_length: full) }}&quot;
}
</code></pre>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos_i18n::reexports::icu::calendar::DateTime;

let i18n = use_i18n();

let datetime_var = move || {
    let date = Date::try_new_iso_date(1970, 1, 2).unwrap().to_any();
    let time = Time::try_new(14, 34, 28, 0).unwrap();
    DateTime::new(date, time)
};

t!(i18n, datetime_formatter, datetime_var);</code></pre>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<pre><code class="language-json">{
  &quot;list_formatter&quot;: &quot;{{ list_var, list }}&quot;
}
</code></pre>
<p>Will format the list based on the locale.
This makes the variable needed to be <code>impl leptos_i18n::formatting::ListFormatterInputFn</code>, which is automatically implemented for <code>impl Fn() -&gt; T + Clone + 'static where T: leptos_i18n::formatting::WriteableList</code>.
<code>WriteableList</code> is a trait to turn a value into an <code>impl Iterator&lt;Item = impl writeable::Writeable&gt;</code>.</p>
<p>Enable the &quot;format_list&quot; feature to use the list formatter.</p>
<h3 id="arguments-5"><a class="header" href="#arguments-5">Arguments</a></h3>
<p>There are two arguments at the moment for the list formatter: <code>list_type</code> and <code>list_length</code>.</p>
<p><code>list_type</code> takes 3 possible values:</p>
<ul>
<li>and</li>
<li>or</li>
<li>unit (Default)</li>
</ul>
<p><code>list_length</code> takes 3 possible values:</p>
<ul>
<li>wide (default)</li>
<li>short</li>
<li>narrow</li>
</ul>
<p>See <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat"><code>Intl.ListFormat</code></a> documentation. <code>icu</code> is used to do the formatting, but I found the Mozilla doc to have more details.</p>
<pre><code class="language-json">{
  &quot;short_and_list_formatter&quot;: &quot;{{ list_var, list(list_type: and; list_length: short) }}&quot;
}
</code></pre>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-rust ignore">use crate::i18n::*;

let i18n = use_i18n();

let list_var = move || [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];

t!(i18n, list_formatter, list_var);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-in-code"><a class="header" href="#how-to-use-in-code">How to use in code</a></h1>
<p>Now that we know how to declare our translations, we can incorporate them into the code, and this is what this chapter covers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="load-the-translations"><a class="header" href="#load-the-translations">Load The Translations</a></h1>
<p>Loading all those translations is the role of the <code>load_locales!</code> macro. Just call this macro anywhere in your codebase, and it will generate the code needed to use your translations.</p>
<pre><code class="language-rust ignore">// lib.rs/main.rs

leptos_i18n::load_locales!();</code></pre>
<h2 id="the-i18n-module"><a class="header" href="#the-i18n-module">The <code>i18n</code> module</a></h2>
<p>The macro will generate a module called <code>i18n</code>. This module contains everything you need to use your translations.</p>
<h3 id="the-locale-enum"><a class="header" href="#the-locale-enum">The <code>Locale</code> enum</a></h3>
<p>You can find the enum <code>Locale</code> in this module. It represents all the locales you declared. For example, this configuration:</p>
<pre><code class="language-toml">[package.metadata.leptos-i18n]
default = &quot;en&quot;
locales = [&quot;en&quot;, &quot;fr&quot;]
</code></pre>
<p>Generate this enum:</p>
<pre><code class="language-rust ignore">#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, Default)]
#[allow(non_camel_case_types)]
pub enum Locale {
    #[default]
    en,
    fr
}</code></pre>
<h3 id="the-i18nkeys-struct"><a class="header" href="#the-i18nkeys-struct">The <code>I18nKeys</code> struct</a></h3>
<p>This generated struct represents the structure of your translations, with each translation key being a key in this struct.</p>
<p>It contains an associated constant for each locale, where every field is populated with the values for the locale.</p>
<p><code>en.json</code></p>
<pre><code class="language-json">{
  &quot;hello_world&quot;: &quot;Hello World!&quot;
}
</code></pre>
<p><code>fr.json</code></p>
<pre><code class="language-json">{
  &quot;hello_world&quot;: &quot;Bonjour le Monde!&quot;
}
</code></pre>
<p>This will generate this struct:</p>
<pre><code class="language-rust ignore">pub struct I18nKeys {
  pub hello_world: &amp;'static str,
}

impl I18nKeys {
  const en: Self = I18nKeys { hello_world: &quot;Hello World!&quot; };
  const fr: Self = I18nKeys { hello_world: &quot;Bonjour le Monde!&quot; };
}

leptos_i18n::load_locales!();

assert_eq!(i18n::I18nKeys::en.hello_world, &quot;Hello World!&quot;);
assert_eq!(i18n::I18nKeys::fr.hello_world, &quot;Bonjour le Monde!&quot;);</code></pre>
<p>This way of accessing the values is possible, but it's not practical and most importantly not reactive. We will cover the <code>t!</code> macro later, which lets you access the values based on the context:</p>
<pre><code class="language-rust ignore">t!(i18n, hello_world)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i18ncontext"><a class="header" href="#i18ncontext"><code>I18nContext</code></a></h1>
<p>The <code>I18nContext</code> type is here to make all your application reactive to the change of the locale. You will use it to access the current locale or change it.</p>
<p>The context is a wrapper around a <code>RwSignal</code> of the current locale. Every getter/setter must be used with the same reasoning as signals.</p>
<h2 id="provide-the-context"><a class="header" href="#provide-the-context">Provide the context</a></h2>
<p>The <code>load_locales!</code> macro generates the <code>I18nContextProvider</code> component in the <code>i18n</code> module,
you can use this component to make the context accessible to all child components.</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

// root of the application
#[component]
pub fn App() -&gt; impl IntoView {
    view! {
        &lt;I18nContextProvider&gt;
            /* */
        &lt;/I18nContextProvider&gt;
    }
}</code></pre>
<h2 id="access-the-context"><a class="header" href="#access-the-context">Access the context</a></h2>
<p>Once provided, you can access it with the <code>use_i18n</code> function, also generated in the <code>i18n</code> module.</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

// somewhere else in the application
#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    view! {
        /* */
    }
}</code></pre>
<h2 id="access-the-current-locale"><a class="header" href="#access-the-current-locale">Access the current locale</a></h2>
<p>With the context, you can access the current locale with the <code>get_locale</code> method:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    create_effect(|_| {
        let locale = i18n.get_locale();
        match locale {
            Locale::en =&gt; {
                log!(&quot;locale en&quot;);
            },
            Locale::fr =&gt; {
                log!(&quot;locale fr&quot;);
            }
        }
    })

    view! {
        /* */
    }
}</code></pre>
<p>If you enable the <code>nightly</code> feature, you can directly call the context: <code>let locale = i18n();</code>.</p>
<p>A non-reactive counterpart to <code>get_locale</code> exists: <code>get_locale_untracked</code>.</p>
<h2 id="change-the-locale"><a class="header" href="#change-the-locale">Change the locale</a></h2>
<p>With the context, you can change the current locale with the <code>set_locale</code> method. For example, this component will switch between <code>en</code> and <code>fr</code> with a button:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    let on_switch = move |_| {
        let new_locale = match i18n.get_locale() {
            Locale::en =&gt; Locale::fr,
            Locale::fr =&gt; Locale::en,
        };
        i18n.set_locale(new_locale);
    };

    view! {
        &lt;button on:click=on_switch&gt;{t!(i18n, click_to_change_lang)}&lt;/button&gt;
    }
}</code></pre>
<p>If you enable the <code>nightly</code> feature, you can directly call the context<code>i18n(new_locale);</code>.</p>
<p>A non-reactive counterpart to <code>set_locale</code> exists: <code>set_locale_untracked</code>.</p>
<h2 id="cookie-feature"><a class="header" href="#cookie-feature"><code>cookie</code> feature</a></h2>
<p>When using the <code>cookie</code> feature, the context will set a cookie whenever the locale changes,
this cookie will be used to decide what locale to use on the page load in CSR,
and on request to the server in SSR by looking at the request headers.</p>
<h2 id="context-options"><a class="header" href="#context-options">Context options</a></h2>
<p>The <code>I18nContextProvider</code> component accepts multiple props, all optional (except children):</p>
<ul>
<li><code>children</code>: obviously</li>
<li><code>set_lang_attr_on_html</code>: should or not set the &quot;lang&quot; attribute on the root <code>&lt;html&gt;</code> element (default to true)</li>
<li><code>set_dir_attr_on_html</code>: should or not set the &quot;dir&quot; attribute on the root <code>&lt;html&gt;</code> element (default to true)</li>
<li><code>enable_cookie</code>: should set a cookie to keep track of the locale when the page reloads (default to true) (do nothing without the &quot;cookie&quot; feature)</li>
<li><code>cookie_name</code>: give a custom name to the cookie (default to the crate default value) (do nothing without the &quot;cookie&quot; feature or if <code>enable_cookie</code> is false)</li>
<li><code>cookie_options</code>: options for the cookie, the value is of type <code>leptos_use::UseCookieOptions&lt;Locale&gt;</code> (default to <code>Default::default</code>)</li>
</ul>
<h2 id="note-on-island"><a class="header" href="#note-on-island">Note on island</a></h2>
<p>If you use the <code>islands</code> feature from Leptos, the <code>I18nContextProvider</code> loses two props: <code>cookie_options</code> and <code>ssr_lang_header_getter</code>, because they are not serializable. If you need them, you can use the <code>init_context_with_options</code> function and provide the context yourself:</p>
<pre><code class="language-rust ignore">use leptos_i18n::init_i18n_context_with_options;
use leptos_i18n::context::{CookieOptions, UseLocalesOptions};
use leptos_meta::Html;
use leptos::prelude::*;
use crate::i18n::*;

#[island]
fn MyI18nProvider(
    enable_cookie: Option&lt;bool&gt;,
    cookie_name: Option&lt;&amp;str&gt;,
    children: Children
) -&gt; impl IntoView {
    let my_cookie_options: CookieOptions&lt;Locale&gt; = /* create your options here */;
    let ssr_lang_header_getter: UseLocalesOptions = /* create your options here */;
    let i18n = init_i18n_context_with_options::&lt;Locale&gt;(
        enable_cookie,
        cookie_name,
        Some(my_cookie_options),
        Some(ssr_lang_header_getter)
    );
    provide_context(i18n);
    let lang = move || i18n.get_locale().as_str();
    let dir = move || i18n.get_locale().direction().as_str();
    view! {
        &lt;Html
            attr:lang=lang
            attr:dir=dir
        /&gt;
        {children}
    }
}</code></pre>
<h2 id="lang-and-dir-html-attributes"><a class="header" href="#lang-and-dir-html-attributes">&quot;lang&quot; and &quot;dir&quot; HTML attributes</a></h2>
<p>You may want to add a &quot;lang&quot; or/and &quot;dir&quot; attribute on an HTML element such that</p>
<pre><code class="language-html">&lt;div lang=&quot;fr&quot;&gt;&lt;/div&gt;
</code></pre>
<p>You could do it yourself by tracking the locale and setting the attribute yourself, but there is a simpler way:</p>
<p>The <code>I18nContext</code> implements <code>Directive</code> from Leptos to set the &quot;lang&quot; attribute, so you can just do</p>
<pre><code class="language-rust ignore">let i18n = use_i18n();

view! {
    &lt;div use:i18n /&gt;
}</code></pre>
<p>And it will set the &quot;lang&quot; and &quot;dir&quot; attributes for you on the <code>&lt;div&gt;</code> element !
<em>Note :</em> Use directives don't work on the server, so don't rely on this for server-side rendering.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sub-context"><a class="header" href="#sub-context">Sub Context</a></h1>
<p>You may want to have sections of your application to use the translations but be isolated from the &quot;main&quot; locale, this is what sub-contexts are for.</p>
<h2 id="why-not-just-use-i18ncontextprovider-"><a class="header" href="#why-not-just-use-i18ncontextprovider-">Why not just use <code>I18nContextProvider</code> ?</a></h2>
<p><code>I18nContextProvider</code> does not shadow any context if one already exists,
this is because it should only be one &quot;main&quot; context, or they will battle for the cookie, the &quot;lang&quot; attribute, the routing, etc.</p>
<p><code>init_i18n_subcontext_*</code> functions create a context that does not battle with the main context and makes it more obvious that a sub-context is created, improving code clarity.</p>
<h2 id="initialize-a-sub-context"><a class="header" href="#initialize-a-sub-context">Initialize a sub-context</a></h2>
<p><code>leptos_i18n::context::init_i18n_subcontext</code> takes an <code>initial_locale: Option&lt;Signal&lt;L&gt;&gt;</code> argument, this is so you can control the sub-context locale outside of it, you can for example make it so the locale of the sub-context is always the opposite of the &quot;main&quot; one:</p>
<pre><code class="language-rust ignore">fn neg_locale(locale: Locale) -&gt; Locale {
    match locale {
        Locale::en =&gt; Locale::fr,
        Locale::fr =&gt; Locale::en
    }
}

fn neg_i18n_signal(i18n: I18nContext&lt;Locale&gt;) -&gt; Signal&lt;Locale&gt; {
    Signal::derive(move || neg_locale(i18n.get()))
}

fn opposite_context() {
    let i18n = use_i18n();
    let ctx = init_i18n_subcontext(Some(neg_i18n_signal(i18n)));
    // ..
}</code></pre>
<p>If it is not supplied, it takes the parent context locale as a default, and if no parent context exists (yes, you can use sub-context as a &quot;main&quot; context if you want), it uses the same locale resolution as the normal context.</p>
<h2 id="providing-a-sub-context"><a class="header" href="#providing-a-sub-context">Providing a sub-context</a></h2>
<p>There is no <code>provide_i18n_subcontext</code>. It does exist but is marked as deprecated; it is not actually deprecated, it is only there as an information point, although it does what you think.</p>
<h4 id="shadowing-correctly"><a class="header" href="#shadowing-correctly">Shadowing correctly</a></h4>
<p>Shadowing a context is not as easy as it sounds:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;
use leptos_i18n::context::provide_i18n_subcontext;

#[component]
fn Foo() -&gt; impl IntoView {
    view! {
        &lt;I18nContextProvider&gt;
            &lt;Sub /&gt;
            &lt;Home /&gt;
        &lt;/I18nContextProvider&gt;
    }
}

#[component]
fn Sub() -&gt; impl IntoView {
    let i18n = provide_i18n_subcontext();
    view! {
        &lt;p&gt;{t!(i18n, sub)}&lt;/p&gt;
    }
}

#[component]
fn Home() -&gt; impl IntoView {
    let i18n = use_i18n();
    view! {
        &lt;p&gt;{t!(i18n, home)}&lt;/p&gt;
    }
}</code></pre>
<p>This will actually make the sub-context provided in the <code>&lt;Sub /&gt;</code> component replace the parent context and leak into the <code>&lt;Home /&gt;</code> component.</p>
<p><code>leptos::provide_context</code> has a section about shadowing in there docs. The best approach is to use a provider:</p>
<pre><code class="language-rust ignore">#[component]
fn Sub() -&gt; impl IntoView {
    let i18n = init_i18n_subcontext();
    view! {
        &lt;Provider value=i18n&gt;
            &lt;p&gt;{t!(i18n, sub)}&lt;/p&gt;
        &lt;/Provider&gt;
    }
}</code></pre>
<p>So this crate has a <code>I18nSubContextProvider</code> generated in the <code>i18n</code> module:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

#[component]
fn Foo() -&gt; impl IntoView {
    view! {
        &lt;I18nContextProvider&gt;
            &lt;I18nSubContextProvider&gt;
                &lt;Sub /&gt;
            &lt;/I18nSubContextProvider&gt;
            &lt;Home /&gt;
        &lt;/I18nContextProvider&gt;
    }
}

#[component]
fn Sub() -&gt; impl IntoView {
    let i18n = use_i18n();
    view! {
        &lt;p&gt;{t!(i18n, sub)}&lt;/p&gt;
    }
}</code></pre>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<p>Same as with the normal context, sub-contexts have behavior control options; they all take the <code>initial_locale: Option&lt;Signal&lt;L&gt;&gt;</code> as their first argument.</p>
<p><code>init_i18n_subcontext_with_options</code> takes options as a cookie;
that function is useless without the <code>cookie</code> feature.</p>
<ul>
<li><code>cookie_name</code> is an option to a name for a cookie to be set to keep state of the chosen locale.</li>
<li><code>cookie_options</code> is an option to some options for a cookie.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-t-macro"><a class="header" href="#the-t-macro">The <code>t!</code> Macro</a></h1>
<p>To access your translations, the <code>t!</code> macro is used. You can access a string with a simple <code>t!(i18n, $key)</code>:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    view! {
        {/* &quot;hello_world&quot;: &quot;Hello World!&quot; */}
        &lt;p&gt;{t!(i18n, hello_world)}&lt;/p&gt;
    }
}</code></pre>
<h2 id="interpolate-values-1"><a class="header" href="#interpolate-values-1">Interpolate Values</a></h2>
<p>If some variables are declared for this key, you can pass them like this:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    let (counter, _set_counter) = signal(0);

    view! {
        {/* &quot;click_count&quot;: &quot;you clicked {{ count }} times&quot; */}
        &lt;p&gt;{t!(i18n, click_count, count = move || counter.get())}&lt;/p&gt;
    }
}</code></pre>
<p>If your variable has the same name as the value, you can pass it directly:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    let (counter, _set_counter) = signal(0);

    let count = move || counter.get();

    view! {
        {/* &quot;click_count&quot;: &quot;you clicked {{ count }} times&quot; */}
        &lt;p&gt;{t!(i18n, click_count, count)}&lt;/p&gt;
    }
}</code></pre>
<p>You can pass anything that implements <code>IntoView + Clone + 'static</code>, you can pass a view if you want:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    let (counter, _set_counter) = signal(0);

    let count = view!{
        &lt;b&gt;
            { move || counter.get() }
        &lt;/b&gt;
    };

    view! {
        {/* &quot;click_count&quot;: &quot;you clicked {{ count }} times&quot; */}
        &lt;p&gt;{t!(i18n, click_count, count)}&lt;/p&gt;
    }
}</code></pre>
<p>Any missing values will generate an error.</p>
<h2 id="interpolate-components-1"><a class="header" href="#interpolate-components-1">Interpolate components</a></h2>
<p>If some components are declared for this key, you can pass them like this:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    let (counter, _set_counter) = signal(0);
    let count = move || counter.get();

    view! {
        {/* &quot;click_count&quot;: &quot;you clicked &lt;b&gt;{{ count }}&lt;/b&gt; times&quot; */}
        &lt;p&gt;{t!(i18n, click_count, count, &lt;b&gt; = |children| view!{ &lt;b&gt;{children}&lt;/b&gt; })}&lt;/p&gt;
    }
}</code></pre>
<p>If your variable has the same name as the component, you can pass it directly:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    let (counter, _set_counter) = signal(0);
    let count = move || counter.get();

    let b = |children| view!{ &lt;b&gt;{children}&lt;/b&gt; };

    view! {
        {/* &quot;click_count&quot;: &quot;you clicked &lt;b&gt;{{ count }}&lt;/b&gt; times&quot; */}
        &lt;p&gt;{t!(i18n, click_count, count, &lt;b&gt;)}&lt;/p&gt;
    }
}</code></pre>
<p>You can pass anything that implements <code>Fn(leptos::ChildrenFn) -&gt; V + Clone + 'static</code> where <code>V: IntoView</code>.</p>
<p>Any missing components will generate an error.</p>
<p><code>|children| view! { &lt;b&gt;{children}&lt;/b&gt; }</code> can be verbose for simple components; you can use this syntax when the children are wrapped by a single component:</p>
<pre><code class="language-rust ignore">// key = &quot;&lt;b&gt;{{ count }}&lt;/b&gt;&quot;
t!(i18n, key, &lt;b&gt; = &lt;span /&gt;, count = 32);</code></pre>
<p>This will render <code>&lt;span&gt;32&lt;/span&gt;</code>.</p>
<p>You can set attributes, event handlers, props, etc.:</p>
<pre><code class="language-rust ignore">t!(i18n, key, &lt;b&gt; = &lt;span attr:id=&quot;my_id&quot; on:click=|_| { /* do stuff */} /&gt;, count = 0);</code></pre>
<p>Basically <code>&lt;name .../&gt;</code> expands to <code>move |children| view! { &lt;name ...&gt;{children}&lt;/name&gt; }</code></p>
<h2 id="ranges-2"><a class="header" href="#ranges-2">Ranges</a></h2>
<p>Ranges expect a variable <code>count</code> that implements <code>Fn() -&gt; N + Clone + 'static</code> where <code>N</code> is the specified type of the range (default is <code>i32</code>).</p>
<pre><code class="language-rust ignore">t!(i18n, key_to_range, count = count);</code></pre>
<h2 id="plurals-1"><a class="header" href="#plurals-1">Plurals</a></h2>
<p>Plurals expect a variable <code>count</code> that implements <code>Fn() -&gt; N + Clone + 'static</code> where <code>N</code> implements <code>Into&lt;icu_plurals::PluralsOperands&gt;</code> (<a href="https://docs.rs/icu/latest/icu/plurals/struct.PluralOperands.html"><code>PluralsOperands</code></a>). Integers and unsigned primitives implement it, along with <code>FixedDecimal</code>.</p>
<pre><code class="language-rust ignore">t!(i18n, key_to_plurals, count = count);</code></pre>
<h2 id="access-subkeys"><a class="header" href="#access-subkeys">Access subkeys</a></h2>
<p>You can access subkeys by simply separating the path with <code>.</code>:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    view! {
        {/*
            &quot;subkeys&quot;: {
                &quot;subkey_1&quot;: &quot;This is subkeys.subkey_1&quot;
            }
        */}
        &lt;p&gt;{t!(i18n, subkeys.subkey_1)}&lt;/p&gt;
    }
}</code></pre>
<h2 id="access-namespaces"><a class="header" href="#access-namespaces">Access namespaces</a></h2>
<p>Namespaces are implemented as subkeys. You first access the namespace, then the keys in that namespace:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    view! {
        &lt;p&gt;{t!(i18n, my_namespace.hello_world)}&lt;/p&gt;
    }
}</code></pre>
<p>To avoid confusion with subkeys, you can use <code>::</code> to separate the namespace name from the rest of the path:</p>
<pre><code class="language-rust ignore">t!(i18n, my_namespace::hello_world)</code></pre>
<h2 id="tu"><a class="header" href="#tu"><code>tu!</code></a></h2>
<p>The <code>tu!</code> macro is the same as <code>t!</code> but untracked.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-td-macro"><a class="header" href="#the-td-macro">The <code>td!</code> Macro</a></h1>
<p>The <code>td!</code> macro works just like the <code>t!</code> macro but instead of taking the context as its first argument, it takes the desired locale:</p>
<pre><code class="language-rust ignore">td!(Locale::fr, hello_world)</code></pre>
<p>This is useful if, for example, you want the buttons to switch locale to always be in the language they switch to:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    view! {
        &lt;For
            each = Locale::get_all
            key = |locale| **locale
            let:locale
        &gt;
            &lt;button on:click = move|_| i18n.set_locale(*locale)&gt;
                {td!(*locale, set_locale)}
            &lt;/button&gt;
        &lt;/For&gt;
    }
}</code></pre>
<p>This could just be written as</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos::prelude::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    view! {
        &lt;button on:click = move|_| i18n.set_locale(Locale::en)&gt;
            {td!(Locale::en, set_locale)}
        &lt;/button&gt;
        &lt;button on:click = move|_| i18n.set_locale(Locale::fr)&gt;
            {td!(Locale::fr, set_locale)}
        &lt;/button&gt;
    }
}</code></pre>
<p>But the above scale is better.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-td_string-macro"><a class="header" href="#the-td_string-macro">The <code>td_string!</code> Macro</a></h1>
<p>The <code>td_string!</code> macro is to use interpolations outside the context of rendering views. It lets you give a different kind of values and return a <code>&amp;'static str</code> or a <code>String</code> depending on the value of the key.
If the value is a plain string or a boolean, it returns a <code>&amp;'static str</code>. If it's an interpolation or a number, it returns a <code>String</code>.</p>
<p>This requires the <code>interpolate_display</code> feature to be enabled to work with interpolations.</p>
<p>It enables you to do this:</p>
<pre><code class="language-rust ignore">// click_count = &quot;You clicked {{ count }} times&quot;
assert_eq!(
    td_string!(Locale::en, click_count, count = 10),
    &quot;You clicked 10 times&quot;
)
assert_eq!(
    td_string!(Locale::en, click_count, count = &quot;a lot of&quot;),
    &quot;You clicked a lot of times&quot;
)</code></pre>
<h3 id="expected-values"><a class="header" href="#expected-values">Expected values</a></h3>
<p>Variables expect anything that implements <code>Display</code>.</p>
<p>If the key uses ranges, it expects the type of the count. If you set the type to <code>f32</code>, it expects a <code>f32</code>.</p>
<p>Components expect a value that implements <code>leptos_i18::display::DisplayComponent</code>. You can find some types made to help with formatting in the <code>display</code> module,
such as <code>DisplayComp</code>.</p>
<p><code>String</code> and <code>&amp;str</code> implement this trait such that</p>
<pre><code class="language-rust ignore">// hello_world = &quot;Hello &lt;b&gt;World&lt;/b&gt; !&quot;

let hw = td_string(Locale::en, hello_world, &lt;b&gt; = &quot;span&quot;);
assert_eq!(hw, &quot;Hello &lt;span&gt;World&lt;/span&gt; !&quot;);</code></pre>
<p>The <code>DisplayComp</code> struct lets you pass leptos attributes:</p>
<pre><code class="language-rust ignore">let attrs = [(&quot;id&quot;, leptos::Attribute::String(&quot;my_id&quot;.into()))];
let b = DisplayComp::new(&quot;div&quot;, &amp;attrs);
let hw = td_string!(Locale::en, hello_world, &lt;b&gt;);
assert_eq!(hw, &quot;Hello &lt;div id=\&quot;my_id\&quot;&gt;World&lt;/div&gt; !&quot;);</code></pre>
<p>If you want finer control over the formatting, you can create your own types implementing the <code>DisplayComponent</code> trait, or you can pass this abomination of a function:</p>
<pre><code class="language-rust ignore">Fn(&amp;mut core::fmt::Formatter, &amp;dyn Fn(&amp;mut core::fmt::Formatter) -&gt; core::fmt::Result) -&gt; core::fmt::Result</code></pre>
<p>which basically lets you do this:</p>
<pre><code class="language-rust ignore">use core::fmt::{Formatter, Result};

fn render_b(f: &amp;mut Formatter, child: &amp;dyn Fn(&amp;mut Formatter) -&gt; Result) -&gt; Result {
    write!(f, &quot;&lt;div id=\&quot;some_id\&quot;&gt;&quot;)?;
    child(f)?; // format the children
    write!(f, &quot;&lt;/div&gt;&quot;)
}

// hello_world = &quot;Hello &lt;b&gt;World&lt;/b&gt; !&quot;
let hw = td_string!(Locale::en, hello_world, &lt;b&gt; = render_b);
assert_eq!(hw, &quot;Hello &lt;div id=\&quot;some_id\&quot;&gt;World&lt;/div&gt; !&quot;);</code></pre>
<p>If you look closely, there are no <code>Clone</code> or <code>'static</code> bounds for any arguments, but they are captured by the value returned by the macro,
so the returned value has a lifetime bound to the &quot;smallest&quot; lifetime of the arguments.</p>
<h1 id="the-td_display-macro"><a class="header" href="#the-td_display-macro">The <code>td_display!</code> Macro</a></h1>
<p>Just like the <code>td_string!</code> macro but returns either a struct implementing <code>Display</code> or a <code>&amp;'static str</code> instead of a <code>Cow&lt;'static, str&gt;</code>.</p>
<p>This is useful if you will print the value or use it in any formatting operation, as it will avoid a temporary <code>String</code>.</p>
<pre><code class="language-rust ignore">use crate::i18n::Locale;
use leptos_i18n::td_display;

// click_count = &quot;You clicked {{ count }} times&quot;
let t = td_display!(Locale::en, click_count, count = 10); // this only returns the builder, no work has been done.
assert_eq!(format!(&quot;before {t} after&quot;), &quot;before You clicked 10 times after&quot;);

let t_str = t.to_string(); // can call `to_string` as the value implements `Display`
assert_eq!(t_str, &quot;You clicked 10 times&quot;);</code></pre>
<h1 id="t_string-t_display-tu_string-and-tu_display"><a class="header" href="#t_string-t_display-tu_string-and-tu_display"><code>t_string</code>, <code>t_display</code>, <code>tu_string</code> and <code>tu_display</code></a></h1>
<p>They also exist, <code>td_string</code> was used here for easier demonstration. Remember that <code>t_string</code> accesses a signal reactively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i18nroute"><a class="header" href="#i18nroute"><code>I18nRoute</code></a></h1>
<p>You can use the <code>leptos_i18n_router</code> crate that exports the <code>I18nRoute</code> component.
This component acts exactly like a <code>leptos_router::Route</code> and takes the same args, except for the path.</p>
<p>What it does is manage a prefix on the URL such that</p>
<pre><code class="language-rust ignore">use crate::i18n::Locale;
use leptos_i18n_router::I118nRoute;
use leptos::prelude::*;
use leptos_router::*;

view! {
    &lt;Router&gt;
        &lt;Routes fallback=||&quot;Page not found&quot;&gt;
            &lt;I18nRoute&lt;Locale, _, _&gt; view=Outlet&gt;
                &lt;Route path=path!(&quot;&quot;) view=Home /&gt;
                &lt;Route path=path!(&quot;counter&quot;) view=Counter /&gt;
            &lt;/I18nRoute&lt;Locale, _, _&gt;&gt;
        &lt;/Routes&gt;
    &lt;/Router&gt;
}</code></pre>
<p>Produce default routes <code>&quot;/&quot;</code> and <code>&quot;/counter&quot;</code>, but also <code>&quot;:locale/&quot;</code> and <code>&quot;:locale/counter&quot;</code> for each locale.</p>
<p>If you have <code>en</code> and <code>fr</code> as your routes, the generated routes will be: <code>/</code>, <code>/counter</code>, <code>/en</code>, <code>/en/counter</code>, <code>/fr</code> and <code>/fr/counter</code>.</p>
<p>This component provides the <code>I18nContext</code> if not already provided, and sets the locale accordingly.</p>
<h2 id="locale-resolution"><a class="header" href="#locale-resolution">Locale resolution</a></h2>
<p>The locale prefix in the URL is considered to have the biggest priority. When accessing <code>&quot;/en/*“</code>, the locale will be set to <code>en</code> no matter what.</p>
<p>But accessing without a locale prefix such as <code>&quot;/counter“</code>, the locale will be resolved based on other factors like cookies, request <code>Accept-Language</code> header, or <code>navigator</code> API.</p>
<p>See the <a href="usage/../infos/01_locale_resol.html">Locale Resolution</a> section.</p>
<h3 id="redirection"><a class="header" href="#redirection">Redirection</a></h3>
<p>If a locale is found those ways and it is not the default locale, this will trigger a navigation to the correct locale prefix.</p>
<p>This means if you access <code>&quot;/counter&quot;</code> with the cookie set to <code>fr</code> (default being <code>en</code>), then you will be redirected to <code>&quot;/fr/counter&quot;</code>.</p>
<h2 id="switching-locale"><a class="header" href="#switching-locale">Switching locale</a></h2>
<p>Switching locale updates the prefix accordingly. Switching from <code>en</code> to <code>fr</code> will set the prefix to <code>fr</code>, but switching to the default locale will remove the locale prefix entirely.</p>
<h2 id="state-keeping"><a class="header" href="#state-keeping">State keeping</a></h2>
<p>Switching locale will trigger a navigation, update the <code>Location</code> returned by <code>use_location</code>, but will not refresh the component tree.</p>
<p>This means that if <code>Counter</code> keeps a count as a state, and you switch locale from <code>fr</code> to <code>en</code>, this will trigger a navigation from <code>&quot;/fr/counter&quot;</code> to <code>&quot;/counter&quot;</code>,
but the component will not be rerendered and the count state will be preserved.</p>
<h2 id="navigation"><a class="header" href="#navigation">Navigation</a></h2>
<p>With the way the default route is handled, if you have a <code>&lt;A href=.. /&gt;</code> link in your application or use <code>leptos_router::use_navigate</code>,
you don't have to worry about removing the locale prefix as this will trigger a redirection to the correct locale.</p>
<p>This redirection also sets <code>NavigateOptions.replace</code> to <code>true</code> so the intermediate location will not show in the history.</p>
<p>Basically, if you are at <code>&quot;/fr/counter&quot;</code> and trigger a redirection to <code>&quot;/&quot;</code>, this will trigger another redirection to <code>&quot;/fr&quot;</code>
and the history will look like you directly navigated from <code>&quot;/fr/counter&quot;</code> to <code>&quot;/fr&quot;</code>.</p>
<h2 id="localized-path-segments"><a class="header" href="#localized-path-segments">Localized path segments</a></h2>
<p>You can use inside the <code>i18nRoute</code> the <code>i18n_path!</code> to create localized path segments:</p>
<pre><code class="language-rust ignore">use leptos_i18n_router::i18n_path;

&lt;I18nRoute&lt;Locale, _, _&gt; view=Outlet&gt;
    &lt;Route path=i18n_path!(Locale, |locale| td_string(locale, segment_path_name)) view={/* */} /&gt;
&lt;/I18nRoute&lt;Locale, _, _&gt;&gt;</code></pre>
<p>If you have <code>segment_path_name = &quot;search&quot;</code> for English, and <code>segment_path_name = &quot;rechercher&quot;</code> for French, the <code>I18nRoute</code> will produce 3 paths:</p>
<ul>
<li>&quot;/search&quot; (if default = &quot;en&quot;)</li>
<li>&quot;/en/search&quot;</li>
<li>&quot;/fr/rechercher&quot;</li>
</ul>
<p>It can be used at any depth, and if not used inside a <code>i18nRoute</code> it will default to the default locale.</p>
<h2 id="caveat"><a class="header" href="#caveat">Caveat</a></h2>
<p>If you have a layout like this:</p>
<pre><code class="language-rust ignore">view! {
    &lt;I18nContextProvider&gt;
        &lt;Menu /&gt;
        &lt;Router&gt;
            &lt;Routes fallback=||&quot;Page not found&quot;&gt;
                &lt;I18nRoute&lt;Locale, _, _&gt; view=Outlet&gt;
                    &lt;Route path=path!(&quot;&quot;) view=Home /&gt;
                &lt;/I18nRoute&lt;Locale, _, _&gt;&gt;
            &lt;/Routes&gt;
        &lt;/Router&gt;
    &lt;/I18nContextProvider&gt;
}</code></pre>
<p>And the <code>Menu</code> component uses localization, you could be surprised to see that sometimes there is a mismatch between the locale used by the <code>Menu</code> and the one inside the router.
This is due to the locale being read from the URL only when the <code>i18nRoute</code> is rendered. So the context may be initialized with another locale, and then hit the router that updates it.</p>
<p>One solution would be to use the <code>Menu</code> component inside the <code>i18nRoute</code>:</p>
<pre><code class="language-rust ignore">view! {
    &lt;I18nContextProvider&gt;
        &lt;Router&gt;
            &lt;Routes fallback=||&quot;Page not found&quot;&gt;
                &lt;I18nRoute&lt;Locale, _, _&gt; view=|| view! {
                    &lt;Menu /&gt;
                    &lt;Outlet /&gt;
                }&gt;
                    &lt;Route path=path!(&quot;&quot;) view=Home /&gt;
                &lt;/I18nRoute&lt;Locale, _, _&gt;&gt;
            &lt;/Routes&gt;
        &lt;/Router&gt;
    &lt;/I18nContextProvider&gt;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoping"><a class="header" href="#scoping">Scoping</a></h1>
<p>If you are using subkeys or namespaces, access keys can get pretty big and repetitive,
wouldn't it be nice to scope a context to a namespace or subkeys ?</p>
<p>Well, this page explains how to do it!</p>
<h2 id="the-scope_i18n-macro"><a class="header" href="#the-scope_i18n-macro">The <code>scope_i18n!</code> macro</a></h2>
<p>Using namespaces and subkeys can make things quite cumbersome very fast. Imagine you have this:</p>
<pre><code class="language-rust ignore">let i18n = use_i18n();

t!(i18n, namespace.subkeys.value);
t!(i18n, namespace.subkeys.more_subkeys.subvalue);
t!(i18n, namespace.subkeys.more_subkeys.another_subvalue);</code></pre>
<p>This only uses <code>namespace.subkeys.*</code>, but we have to repeat it everywhere. Well,
well here comes the <code>scope_i18n!</code> macro. You can rewrite it to:</p>
<pre><code class="language-rust ignore">let i18n = use_i18n();
let i18n = scope_i18n!(i18n, namespace.subkeys);

t!(i18n, value);
t!(i18n, more_subkeys.subvalue);
t!(i18n, more_subkeys.another_subvalue);</code></pre>
<p>This macro can be chained:</p>
<pre><code class="language-rust ignore">let i18n = use_i18n();
let i18n = scope_i18n!(i18n, namespace);
let i18n = scope_i18n!(i18n, subkeys);

t!(i18n, value);

let i18n = scope_i18n!(i18n, more_subkeys);
t!(i18n, subvalue);
t!(i18n, another_subvalue);</code></pre>
<h2 id="the-use_i18n_scoped-macro"><a class="header" href="#the-use_i18n_scoped-macro">The <code>use_i18n_scoped!</code> macro</a></h2>
<p>In the above example, we do <code>let i18n = use_i18n();</code> but only access the context to scope it afterward. We could do</p>
<pre><code class="language-rust ignore">let i18n = scope_i18n!(use_i18n(), namespace.subkeys);</code></pre>
<p>Well, this is what the <code>use_i18n_scoped!</code> macro is for:</p>
<pre><code class="language-rust ignore">let i18n = use_i18n_scoped!(namespace.subkeys);

t!(i18n, value);
t!(i18n, more_subkeys.subvalue);
t!(i18n, more_subkeys.another_subvalue);</code></pre>
<h2 id="the-scope_locale-macro"><a class="header" href="#the-scope_locale-macro">The <code>scope_locale!</code> macro</a></h2>
<p>The above examples are to scope a context, but maybe you use <code>td!</code> a lot and run into the same problems:</p>
<pre><code class="language-rust ignore">fn foo(locale: Locale) {
    td!(locale, namespace.subkeys.value);
    td!(locale, namespace.subkeys.more_subkeys.subvalue);
    td!(locale, namespace.subkeys.more_subkeys.another_subvalue);
}</code></pre>
<p>You can use the <code>scope_locale!</code> macro here:</p>
<pre><code class="language-rust ignore">fn foo(locale: Locale) {
    let locale = scope_locale!(locale, namespace.subkeys);
    td!(locale, value);
    td!(locale, more_subkeys.subvalue);
    td!(locale, more_subkeys.another_subvalue);
}</code></pre>
<p>And again, it is chainable:</p>
<pre><code class="language-rust ignore">fn foo(locale: Locale) {
    let locale = scope_locale!(locale, namespace.subkeys);
    td!(locale, value);
    let locale = scope_locale!(locale, more_subkeys);
    td!(locale, subvalue);
    td!(locale, another_subvalue);
}</code></pre>
<h2 id="caveat-1"><a class="header" href="#caveat-1">Caveat</a></h2>
<p>Unfortunately, it looks too good to be true... What's the catch ? Where is the tradeoff ?</p>
<p>To make this possible, it uses a typestate pattern, but some of the types are hard to access as a user as they are defined deep in the generated <code>i18n</code> module.
This makes it difficult to write the type of a scoped context or a scoped locale.</p>
<p>By default, <code>I18nContext&lt;L, S&gt;</code> is only generic over <code>L</code> because the <code>S</code> scope is the &quot;default&quot; one provided by <code>L</code>, so you can easily write <code>I18nContext&lt;Locale&gt;</code>.
But once you scope it, the <code>S</code> parameters will look like <code>i18n::namespaces::ns_namespace::subkeys::sk_subkeys::subkeys_subkeys</code>.</p>
<p>Yes. This is the path to the struct holding the keys of <code>namespace.subkeys</code>.</p>
<p>This makes it difficult to pass a scoped type around, as it would require writing <code>I18nContext&lt;Locale, i18n::namespaces::ns_namespace::subkeys::sk_subkeys::subkeys_subkeys&gt;</code>.</p>
<p>Maybe in the future there will be a macro to write this horrible path for you, but I don't think it is really needed for now.</p>
<p>If you look at the generated code you will see this:</p>
<pre><code class="language-rust ignore">let i18n = { leptos_i18n::__private::scope_ctx_util(use_i18n(), |_k| &amp;_k.$keys) };</code></pre>
<p>Hmm, what is this closure for? It’s just here for type inference and key checking! The function parameter is even <code>_:fn(&amp;OS) -&gt; &amp;NS</code>, it's never used.
The function is even const (not for <code>scope_locale</code> though, the only one that could really benefit from it lol, because trait functions can't be const...).</p>
<p>But being a typestate using it or not actually results in the same code path.
And with how aggressive Rust is with inlining small functions, it probably compiles to the exact same thing.
So no runtime performance loss! Yeah!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="t_format"><a class="header" href="#t_format"><code>t_format!</code></a></h1>
<p>You may want to use the formatting capability without the need to create an entry in your translations; you can use the <code>t_format!</code> macro for that:</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
use leptos_i18n::formatting::t_format;

let i18n = use_i18n();

let num = move || 100_000;

t_format!(i18n, num, formatter: number);</code></pre>
<p>There are 9 variants, just like the <code>t!</code> macro, <code>td_format!</code>, <code>tu_format!</code>, <code>*_format_string</code>, and <code>*_format_display</code>.</p>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><code class="language-rust ignore">let date = move || Date::try_new_iso_date(1970, 1, 2).unwrap().to_any();

let en = td_format_string!(Locale::en, date, formatter: date);
assert_eq!(en, &quot;Jan 2, 1970&quot;);
let fr = td_format_string!(Locale::fr, date, formatter: date(date_length: full));
assert_eq!(fr, &quot;vendredi 2 janvier 1970&quot;);

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="t_plural"><a class="header" href="#t_plural"><code>t_plural!</code></a></h1>
<p>You can use the <code>t_plural!</code> macro to match on the plural form of a given count:</p>
<pre><code class="language-rust ignore">let i18n = use_i18n();

let form = t_plural! {
    i18n,
    count = || 0,
    one =&gt; &quot;one&quot;,
    _ =&gt; &quot;other&quot;
};

Effect::new(|| {
    let s = form();
    log!(&quot;{}&quot;, s);
})</code></pre>
<p>This will print &quot;one&quot; with locale &quot;fr&quot; but &quot;other&quot; with locale &quot;en&quot;.
Accepted forms are: <code>zero</code>, <code>one</code>, <code>two</code>, <code>few</code>, <code>many</code>, <code>other</code>, and <code>_</code>.</p>
<p>This macro is for cardinal plurals; if you want to match against ordinal plurals, use the <code>t_plural_ordinal!</code> macro.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-translations-in-a-const-context"><a class="header" href="#access-translations-in-a-const-context">Access translations in a const context</a></h1>
<p>You can access the translations in a const context if you have those things:</p>
<ul>
<li>Constant Locale</li>
<li>No arguments</li>
<li>No using the &quot;dynamic_load&quot; feature</li>
</ul>
<p>If you have</p>
<pre><code class="language-json">{
  &quot;subkeys:&quot;: {
    &quot;key&quot;: &quot;my value&quot;
  }
}
</code></pre>
<p>You can do</p>
<pre><code class="language-rust ignore">use crate::i18n::*;
const MY_VALUE: &amp;str = Locale::en.get_keys_const().subkeys().key().inner();</code></pre>
<p>If you want a macro:</p>
<pre><code class="language-rust ignore">macro_rules! td_const {
    ($locale:expr, $first_key:ident $(.$key:ident)*) =&gt; {
        ($locale).get_keys_const()
            .$first_key()
            $(.$key())*
            .inner()
    };
}

const MY_VALUE: &amp;str = td_const(Locale::en, subkeys.key);

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-functions"><a class="header" href="#server-functions">Server functions</a></h1>
<p>There is no context in server functions, so you can't call <code>use_i18n</code>. You could provide a context if you want,
and it would work as expected, but if you just want to access what locale the user is using you can use the <code>resolve_locale</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[server]
async fn get_locale() -&gt; Result&lt;Locale, ServerFnError&gt; {
    let locale: Locale = leptos_i18n::locale::resolve_locale();
    Ok(locale)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-information"><a class="header" href="#more-information">More Information</a></h1>
<p>This chapter covers more information that details some behavior that is expected, such as how the locale resolution is done.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="locale-resolution-1"><a class="header" href="#locale-resolution-1">Locale Resolution</a></h1>
<p>This library handles the detection of what locale to use for you, but it can be done in a multitude of ways.</p>
<p>Here is the list of detection methods, sorted in priorities:</p>
<ol>
<li>A locale prefix is present in the URL pathname when using <code>I18nRoute</code> (e.g. <code>/en/about</code>)</li>
<li>A cookie is present that contains a previously detected locale</li>
<li>A locale can be matched based on the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language"><code>Accept-Language</code> header</a> in SSR</li>
<li>A locale can be matched based on the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/languages"><code>navigator.languages</code> API</a> in CSR</li>
<li>As a last resort, the default locale is used.</li>
</ol>
<p>In SSR, it is always the server that resolves what locale to use; the client does not try to compute a locale when loading; the only locale changes that can happen are by explicitly setting it in the context.</p>
<p><em>note</em>: URL pathname locale has a behavior that can be unexpected, it only resolve when the <code>I18nRoute</code> component start rendering, so if anything relied on the resolved locale before it,
it may have used a different locale than what it should. You can learn more on the <a href="infos/../usage/07_router.html#caveat">caveat section of the router chapter</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-reduce-binary-size"><a class="header" href="#how-to-reduce-binary-size">How To Reduce Binary Size</a></h1>
<p>This chapter is about the few options you have to reduce the binary footprint of this library, other than compiler options such as <code>opt-level = &quot;z&quot;</code> and other things that are common for every build.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="icu4x-datagen"><a class="header" href="#icu4x-datagen">ICU4X Datagen</a></h1>
<p>This library uses ICU4X as a backend for formatters and plurals, and the default baked data provider can take quite a lot of space as it contains information for <em>every possible locale</em>. So if you use only a few, this is a complete waste.</p>
<h2 id="disable-compiled-data"><a class="header" href="#disable-compiled-data">Disable compiled data</a></h2>
<p>The first step to remove those excess informations is to disable the default data provider; it is activated by the <code>&quot;icu_compiled_data&quot;</code> feature that is enabled by default. So turn off default features or remove this feature.</p>
<h2 id="custom-provider"><a class="header" href="#custom-provider">Custom provider</a></h2>
<p>Great, we lost a lot of size, but now instead of having too much information, we have 0 information. You will now need to bring your own data provider. For that, you will need multiple things.</p>
<h2 id="1-datagen"><a class="header" href="#1-datagen">1. Datagen</a></h2>
<p>First, generate the information; you can use <a href="https://docs.rs/icu_datagen/latest/icu_datagen/"><code>icu_datagen</code></a> for that, either as a CLI or with a build.rs (we will come back to it later).</p>
<h2 id="2-load"><a class="header" href="#2-load">2. Load</a></h2>
<p>Then you need to load those informations; this is as simple as</p>
<pre><code class="language-rust ignore">include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/baked_data/mod.rs&quot;));

pub struct MyDataProvider;
impl_data_provider!(MyDataProvider);</code></pre>
<p>you will also need some depedencies:</p>
<pre><code class="language-toml">[dependencies]
# &quot;default-features = false&quot; to turn off compiled_data
icu = { version = &quot;1.5&quot;, default-features = false }
icu_provider = &quot;1.5&quot; # for databake
zerovec = &quot;0.10&quot; # for databake
</code></pre>
<p>This is explained more in depth in the <code>icu_datagen</code> doc.</p>
<h2 id="3-supply-to-leptos_i18n-the-provider"><a class="header" href="#3-supply-to-leptos_i18n-the-provider">3. Supply to leptos_i18n the provider.</a></h2>
<p>You now just need to tell <code>leptos_i18n</code> what provider to use. For that, you first need to implement <code>IcuDataProvider</code> for your provider. You can do it manually as it is straightforward, but the lib comes with a derive macro:</p>
<pre><code class="language-rust ignore">include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/baked_data/mod.rs&quot;));

#[derive(leptos_i18n::custom_provider::IcuDataProvider)]
pub struct MyDataProvider;
impl_data_provider!(MyDataProvider);</code></pre>
<p>And then pass it to the <code>set_icu_data_provider</code> function when the program starts,
so for CSR apps in the main function:</p>
<pre><code class="language-rust ignore">fn main() {
    leptos_i18n::custom_provider::set_icu_data_provider(MyDataProvider);
    console_error_panic_hook::set_once();
    leptos::mount::mount_to_body(|| leptos::view! { &lt;App /&gt; })
}</code></pre>
<p>and for SSR apps in both on hydrate and on server startup:</p>
<pre><code class="language-rust ignore">#[wasm_bindgen::prelude::wasm_bindgen]
pub fn hydrate() {
    leptos_i18n::custom_provider::set_icu_data_provider(MyDataProvider);
    console_error_panic_hook::set_once();
    leptos::mount::hydrate_body(App);
}</code></pre>
<pre><code class="language-rust ignore">// example for actix
#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    leptos_i18n::custom_provider::set_icu_data_provider(MyDataProvider);
    // ..
}</code></pre>
<h2 id="buildrs-datagen"><a class="header" href="#buildrs-datagen">Build.rs datagen</a></h2>
<p>The doc for ICU4X datagen can be quite intimidating, but it is actually quite straightforward. Your build.rs can look like this:</p>
<pre><code class="language-rust ignore">use icu_datagen::baked_exporter::*;
use icu_datagen::prelude::*;
use std::path::PathBuf;

fn main() {
    println!(&quot;cargo:rerun-if-changed=build.rs&quot;);

    let mod_directory = PathBuf::from(std::env::var_os(&quot;OUT_DIR&quot;).unwrap()).join(&quot;baked_data&quot;);

    let exporter = BakedExporter::new(mod_directory, Default::default()).unwrap();

    DatagenDriver::new()
        // Keys needed for plurals
        .with_keys(icu_datagen::keys(&amp;[
            &quot;plurals/cardinal@1&quot;,
            &quot;plurals/ordinal@1&quot;,
        ]))
        // Used locales, no fallback needed
        .with_locales_no_fallback([langid!(&quot;en&quot;), langid!(&quot;fr&quot;)], Default::default())
        .export(&amp;DatagenProvider::new_latest_tested(), exporter)
        .unwrap();
}</code></pre>
<p>Here we are generating the information for locales <code>&quot;en&quot;</code> and <code>&quot;fr&quot;</code>, with the data needed for plurals.</p>
<h2 id="using-leptos_i18n_build-crate"><a class="header" href="#using-leptos_i18n_build-crate">Using <code>leptos_i18n_build</code> crate</a></h2>
<p>You can use the <code>leptos_i18n_build</code> crate that contains utils for the datagen.
The problem with the above <code>build.rs</code> is that it can go out of sync with your translations,
when all information is already in the translations.</p>
<pre><code class="language-toml"># Cargo.toml
[build-dependencies]
leptos_i18n_build = &quot;0.5.0&quot;
</code></pre>
<pre><code class="language-rust ignore">use leptos_i18n_build::TranslationsInfos;
use std::path::PathBuf;

fn main() {
    println!(&quot;cargo:rerun-if-changed=build.rs&quot;);
    println!(&quot;cargo:rerun-if-changed=Cargo.toml&quot;);

    let mod_directory = PathBuf::from(std::env::var_os(&quot;OUT_DIR&quot;).unwrap()).join(&quot;baked_data&quot;);

    let translations_infos = TranslationsInfos::parse().unwrap();

    translations_infos.rerun_if_locales_changed();

    translations_infos.generate_data(mod_directory).unwrap();
}</code></pre>
<p>This will parse the config and the translations and generate the data for you using the information gained when parsing the translations.
This will trigger a rerun if the config or translations changed and be kept in sync.
If your code uses plurals, it will build with information for plurals. If it uses a formatter, it will build with the information for that formatter.</p>
<p>If you use more data somehow, like for example using <code>t*_format!</code> with a formatter not used in the translations, there are functions to either supply additional options or keys:</p>
<pre><code class="language-rust ignore">use leptos_i18n_build::Options;

translations_infos.generate_data_with_options(mod_directory, [Options::FormatDateTime]).unwrap();</code></pre>
<p>This will inject the ICU <code>DataKey</code>s needed for the <code>date</code>, <code>time</code>, and <code>datetime</code> formatters.</p>
<pre><code class="language-rust ignore">use leptos_i18n_build::Options;

translations_infos.generate_data_with_data_keys(
    mod_directory,
    icu_datagen::keys(&amp;[&quot;plurals/cardinal@1&quot;, &quot;plurals/ordinal@1&quot;])
).unwrap();</code></pre>
<p>This will inject the keys for cardinal and ordinal plurals.</p>
<p>If you need both, <code>Options</code> can be turned into the needed keys:</p>
<pre><code class="language-rust ignore">use leptos_i18n_build::Options;

let mut keys = icu_datagen::keys(&amp;[&quot;plurals/cardinal@1&quot;, &quot;plurals/ordinal@1&quot;])
let keys.extend(Options::FormatDateTime.into_data_keys())

// keys now contains the `DataKey`s needed for plurals and for the `time`, `date` and `datetime` formatters.

translations_infos.generate_data_with_data_keys(mod_directory, keys).unwrap();</code></pre>
<h2 id="is-it-worth-the-trouble-"><a class="header" href="#is-it-worth-the-trouble-">Is it worth the trouble ?</a></h2>
<p>YES. With <code>opt-level = &quot;z&quot;</code> and <code>lto = true</code>, the plurals example is at 394 kB (at the time of writing). Now, by just providing a custom provider tailored to the used locales (&quot;en&quot; and &quot;fr&quot;), it shrinks down to 248 kB! It almost cut in half the binary size!
I highly suggest taking the time to implement this.</p>
<h1 id="experimental-features"><a class="header" href="#experimental-features">Experimental features</a></h1>
<p>When using experimental features, such as &quot;format_currency&quot;, if you follow the step above you will probably have some compilation error in the <code>impl_data_provider!</code> macro.
To solve them you will need those few things:</p>
<h3 id="enable-experimental-feature"><a class="header" href="#enable-experimental-feature">Enable experimental feature</a></h3>
<p>Enable the &quot;experimental&quot; feature for <code>icu</code>:</p>
<pre><code class="language-toml"># Cargo.toml
[depedencies]
icu = {
    version = &quot;1.5.0&quot;,
    default-features = false,
    features = [ &quot;experimental&quot;]
}
</code></pre>
<h3 id="import-icu_pattern"><a class="header" href="#import-icu_pattern">Import <code>icu_pattern</code></a></h3>
<pre><code class="language-toml"># Cargo.toml
[depedencies]
icu_pattern = &quot;0.2.0&quot; # for databake
</code></pre>
<h3 id="import-the-alloc-crate"><a class="header" href="#import-the-alloc-crate">Import the <code>alloc</code> crate</a></h3>
<p>The macro directly use the <code>alloc</code> crate instead of the std, so you must bring it into scope:</p>
<pre><code class="language-rust ignore">extern crate alloc;

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/baked_data/mod.rs&quot;));

pub struct MyDataProvider;
impl_data_provider!(MyDataProvider);</code></pre>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<p>You can take a look at the <code>counter_icu_datagen</code> example. This is a copy of the <code>counter_plurals</code> example but with a custom provider.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-loading-of-translations"><a class="header" href="#dynamic-loading-of-translations">Dynamic loading of translations</a></h1>
<h2 id="why-use-it-"><a class="header" href="#why-use-it-">Why use it ?</a></h2>
<p>By default, the translations are loaded at compile time and are baked into the binary,
this has some performance advantages but comes at a cost: binary size.
This is fine when the number of keys and locales is small and the values are not long,
but when supporting a high number of locales and with a lot of keys, binary sizes start to increase highly.</p>
<p>The <code>&quot;dynamic_load&quot;</code> feature reduces this binary size increase by removing the baked translations in the binary and lazy loading them on the client.
The way it does that is by using a server function to request the translations in a given &quot;translation unit&quot;.
What I call &quot;translation unit&quot; is a group of translations; they are either one unit per locale or one unit per locale per namespaces if you use them.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>When using SSR, the server will register every unit used for a given request and bake only the used one in the sent HTML.
They are then parsed when the client hydrates, so no request for translations is done on page load.
When the client needs access to an unloaded unit, it will request it from the server and will update the view when received.</p>
<h2 id="what-changes-"><a class="header" href="#what-changes-">What changes ?</a></h2>
<h3 id="async-accessors"><a class="header" href="#async-accessors">Async accessors</a></h3>
<p>For obvious reasons, with the <code>&quot;dynamic_load&quot;</code> accessing a value is now async, <code>t!</code>, <code>td!</code> and <code>tu!</code> still return <code>impl Fn() -&gt; impl IntoView</code>, as the async part is handled inside of it with some optimizations, but the <code>*_display!</code> and <code>*_string!</code> variants now return a future and need to be awaited.</p>
<p>You can turn them into some kind of <code>Signal&lt;Option&lt;String&gt;&gt;</code> using leptos <code>AsyncDerived</code>:</p>
<pre><code class="language-rust ignore">let i18n = use_i18n();
let translation = AsyncDerived::new(move || t_string!(i18n, key)); // .get() will return an `Option&lt;&amp;'static str&gt;`</code></pre>
<p>Feel free to make yourself a macro to wrap them:</p>
<pre><code class="language-rust ignore">macro_rules! t_string_async {
    ($($tt:tt),*) =&gt; {
        leptos::prelude::AsyncDerived::new(move || leptos_i18n::t_string!($($tt),*))
    }
}</code></pre>
<p>This could have been the design by default, but there are multiple ways to handle it so I decided to leave the choice to the user.</p>
<p><em>note</em>: They are technically not needed to be async on the server, as translations are still baked in for them,
but for the API to be the same on the client and the server they return the value wrapped in an async block.</p>
<h3 id="server-fn"><a class="header" href="#server-fn">Server Fn</a></h3>
<p>If you use a backend that needs to manually register server functions,
you can use the <code>ServerFn</code> associated type on the <code>Locale</code> trait implemented by the generated <code>Locale</code> enum:</p>
<pre><code class="language-rust ignore">use i18n::Locale;
use leptos_i18n::Locale as LocaleTrait;

register_server_fn::&lt;&lt;Locale as LocaleTrait&gt;::ServerFn&gt;();</code></pre>
<h3 id="csr"><a class="header" href="#csr">CSR</a></h3>
<p>With SSR the translations are served by a server functions, but they don't exist with CSR, so you will need to create a static JSON containing them, so a bit more work is needed.
To do that you can use a build script and use the <code>leptos_i18n_build</code> crate:</p>
<pre><code class="language-toml"># Cargo.toml
[build-dependencies]
leptos_i18n_build = &quot;0.5.0&quot;
</code></pre>
<pre><pre class="playground"><code class="language-rust">use leptos_i18n_build::TranslationsInfos;

fn main() {
    println!(&quot;cargo:rerun-if-changed=build.rs&quot;);
    println!(&quot;cargo:rerun-if-changed=Cargo.toml&quot;);

    let translations_infos = TranslationsInfos::parse().unwrap();

    translations_infos.rerun_if_locales_changed();

    translations_infos
        .get_translations()
        .write_to_dir(&quot;path/to/dir&quot;)
        .unwrap();
}</code></pre></pre>
<p>This will generate the need JSON files in the given directory, for exemple you could generate them in <code>target/i18n</code>, giving this file structure:</p>
<pre><code class="language-bash">./target
└── i18n
    ├── locale1.json
    └── locale2.json
</code></pre>
<p>If you are using namespaces it would have this one:</p>
<pre><code class="language-bash">./target
└── i18n
    └── namespace1
        ├── locale1.json
        └── locale2.json
    └── namespace2
        ├── locale1.json
        └── locale2.json
</code></pre>
<p>Then if you are using Trunk you just have to add the directory to the build pipeline:</p>
<pre><code class="language-html">&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;link data-trunk rel=&quot;copy-dir&quot; href=&quot;./target/i18n&quot; /&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Now the translations will be available at <code>i18n/{locale}.json</code>
To inform <code>leptos_i18n</code> where to find those translations you need to supply the <code>translations-path</code> field under <code>[package.metadata.leptos-i18n]</code>:</p>
<pre><code class="language-toml"># Cargo.toml
[package.metadata.leptos-i18n]
translations-path = &quot;i18n/{locale}.json&quot; # or &quot;i18n/{namespace}/{locale}.json&quot; when using namespaces
</code></pre>
<p>And this is it!</p>
<h2 id="disclaimers"><a class="header" href="#disclaimers">Disclaimers</a></h2>
<ol>
<li>
<p>There is a chance that enabling this feature actually increases binary sizes if there aren’t many translations,
as there is additional code being generated to request, parse, and load the translations. But this is mostly a fixed cost,
so with enough translations, the trade will be beneficial. So do some testing.</p>
</li>
<li>
<p>Only the raw strings are removed from the binary; the code to render each key is still baked in it, whatever the locale or the namespace.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>You can find here all the available features of the crate.</p>
<h4 id="actix"><a class="header" href="#actix"><code>actix</code></a></h4>
<p>This feature must be enabled when building the server with the actix backend.</p>
<h4 id="axum"><a class="header" href="#axum"><code>axum</code></a></h4>
<p>This feature must be enabled when building the server with the actix backend.</p>
<h3 id="ssr"><a class="header" href="#ssr"><code>ssr</code></a></h3>
<p>This feature must be enabled when building the server. It is automatically enabled by the <code>actix</code> or <code>axum</code> features, but if you use another backend, you can use this feature and provide custom functions to get access to the request headers.</p>
<h4 id="hydrate-1"><a class="header" href="#hydrate-1"><code>hydrate</code></a></h4>
<p>This feature must be enabled when building the client in ssr mode.</p>
<h4 id="csr-1"><a class="header" href="#csr-1"><code>csr</code></a></h4>
<p>This feature must be enabled when building the client in csr mode.</p>
<h4 id="cookie-default"><a class="header" href="#cookie-default"><code>cookie</code> (Default)</a></h4>
<p>Set a cookie to remember the last chosen locale.</p>
<h4 id="islands"><a class="header" href="#islands"><code>islands</code></a></h4>
<p>This feature is, as its name says, experimental.
This makes this lib somewhat usable when using <code>islands</code> with Leptos.</p>
<h4 id="serde"><a class="header" href="#serde"><code>serde</code></a></h4>
<p>This feature implements <code>Serialize</code> and <code>Deserialize</code> for the <code>Locale</code> enum.</p>
<h4 id="interpolate_display"><a class="header" href="#interpolate_display"><code>interpolate_display</code></a></h4>
<p>This feature generates extra code for each interpolation to allow rendering them as a string instead of a <code>View</code>.</p>
<h4 id="show_keys_only"><a class="header" href="#show_keys_only"><code>show_keys_only</code></a></h4>
<p>This feature makes every translation to only display its corresponding key; this is useful to track untranslated strings in your application.</p>
<h4 id="suppress_key_warnings"><a class="header" href="#suppress_key_warnings"><code>suppress_key_warnings</code></a></h4>
<p>This feature disables the warnings when a key is missing or in surplus; we discourage its usage and highly encourage the use of explicit defaults, but if it’s what you want, we won't stop you.</p>
<h4 id="json_files-default"><a class="header" href="#json_files-default"><code>json_files</code> (Default)</a></h4>
<p>To enable when you use JSON files for your locales.</p>
<h4 id="yaml_files"><a class="header" href="#yaml_files"><code>yaml_files</code></a></h4>
<p>To enable when you use YAML files for your locales.</p>
<h4 id="nightly"><a class="header" href="#nightly"><code>nightly</code></a></h4>
<p>Enable the use of some nightly features, like directly calling the context to get/set the current locale
and allow the <code>load_locale!</code> macro to emit better warnings.</p>
<h4 id="track_locale_files"><a class="header" href="#track_locale_files"><code>track_locale_files</code></a></h4>
<p>Allow tracking of locale files as dependencies for rebuilds in stable.
The <code>load_locales!()</code> macro uses external dependencies that the build system is not aware of. The macro should be rerun when those files changes,
you may have noticed that if you use <code>cargo-leptos</code> with <code>watch-additional-files = [&quot;locales&quot;]</code> and running <code>cargo leptos watch</code>, even if the file changes and cargo-leptos triggers a rebuild, nothing changes.
This feature uses a &quot;trick&quot; by using <code>include_bytes!()</code> to declare the use of a file, but I'm a bit sceptical of the impact on build time using this.
I've already checked and it does not include the bytes in the final binary, even in debug, but it may slow down compilation time.
If you use the <code>nightly</code> feature, it uses the <a href="https://github.com/rust-lang/rust/issues/99515">path tracking API</a> so no trick using <code>include_bytes!</code> and the possible slowdown in compile times coming with it.</p>
<h4 id="icu_compiled_data-default"><a class="header" href="#icu_compiled_data-default"><code>icu_compiled_data</code> (Default)</a></h4>
<p>ICU4X is used as a backend for formatting and plurals. They bring their own data to know what to do for each locale. This is great when starting up a project without knowing exactly what you need. This is why it is enabled by default, so things work right out of the box.
But those baked data can take quite a lot of space in the final binary as they bring information for all possible locales, so if you want to reduce this footprint, you can disable this feature and provide your own data with selected information. See the datagen section in the reduce binary size chapter for more information.</p>
<h4 id="plurals-2"><a class="header" href="#plurals-2"><code>plurals</code></a></h4>
<p>Allow the use of plurals in translations.</p>
<h4 id="format_datetime"><a class="header" href="#format_datetime"><code>format_datetime</code></a></h4>
<p>Allow the use of the <code>date</code>, <code>time</code>, and <code>datetime</code> formatters.</p>
<h4 id="format_list"><a class="header" href="#format_list"><code>format_list</code></a></h4>
<p>Allow the use of the <code>list</code> formatter.</p>
<h4 id="format_nums"><a class="header" href="#format_nums"><code>format_nums</code></a></h4>
<p>Allow the use of the <code>number</code> formatter.</p>
<h4 id="format_currency"><a class="header" href="#format_currency"><code>format_currency</code></a></h4>
<p>Allow the use of the <code>currency</code> formatter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-i18n-ally-vs-code-extension"><a class="header" href="#the-i18n-ally-vs-code-extension">The <code>i18n Ally</code> VS Code extension</a></h1>
<p>The <a href="https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally"><code>i18n Ally</code></a> extension is an extension
that has a bunch of features for managing, structuring, and even automating translations, with the most notable one being an overlay over translations keys
in the code displaying the corresponding translations.</p>
<p>This is very helpful, and this section is a guide for a minimal setup to make this extension work with <code>Leptos i18n</code>.</p>
<h2 id="custom-framework-setup"><a class="header" href="#custom-framework-setup">Custom framework setup</a></h2>
<p>For obvious reasons, this lib is not supported by <code>i18n Ally</code> (one day maybe ?), but the awesome people working on that extension
gave us <a href="https://github.com/lokalise/i18n-ally/wiki/Custom-Framework">a way</a> to make it work with custom frameworks.</p>
<p>You will need to first create a file in your <code>.vscode</code> folder named <code>i18n-ally-custom-framework.yml</code> and put this in it:</p>
<pre><code class="language-yaml">languageIds:
  - rust

usageMatchRegex:
  - &quot;[^\\w\\d]t!\\(\\s*[\\w.:]*,\\s*([\\w.]*)&quot;
  - &quot;[^\\w\\d]td!\\(\\s*[\\w.:]*,\\s*([\\w.]*)&quot;
  - &quot;[^\\w\\d]td_string!\\(\\s*[\\w.:]*,\\s*([\\w.]*)&quot;
  - &quot;[^\\w\\d]td_display!\\(\\s*[\\w.:]*,\\s*([\\w.]*)&quot;

monopoly: true
</code></pre>
<p><code>languageIds</code> is the language you are using in your project. I'm no expert, but this is probably for a VSC API to know what files to check.</p>
<p><code>usageMatchRegex</code> is the regex to use to find the translations keys; the above regex are for, in order, <code>t!</code>, <code>td!</code>, <code>td_string!</code> and <code>td_display!</code>. If you don't use all translations macros, you can remove/comment out the regex for that macro. Those regex are not perfect, and I'm no expert, so there may be some better/faster ones, and if you encounter a problem with them, feel free to open an issue/discussion on GitHub about it.</p>
<p><code>monopoly</code> is to disable all supported frameworks; if you use any other frameworks supported by the extension in your project, set it to <code>false</code>.</p>
<h2 id="common-settings"><a class="header" href="#common-settings">Common settings</a></h2>
<p>There are multiple settings for the extension that you can set in <code>.vscode/settings.json</code>; those are all optional. Here is a non-exhaustive list with their (default):</p>
<ul>
<li>
<p><code>i18n-ally.keystyle</code> (auto): this one can be <code>flat</code> (<code>&quot;a.b.c&quot;: &quot;...&quot;</code>) or <code>nested</code> (<code>&quot;a&quot;: { &quot;b&quot;: { &quot;c&quot;: &quot;...&quot; } }</code>), this is irrelevant to you if you don't use subkeys, but if you do, set it to <code>&quot;nested&quot;</code> as this is the style that this lib supports.</p>
</li>
<li>
<p><code>i18n-ally.localesPaths</code> (auto): this is the path to your locales; it can be a path or a list of paths. By default, set it to <code>&quot;locales&quot;</code>, but if you either have a custom locales path or use a cargo workspaces, you will have to supply the path here.</p>
</li>
<li>
<p><code>i18n-ally.namespace</code> (false): this is if you use namespaces; set it to <code>true</code> then. If you use namespaces with <code>i18n Ally</code>, I have not figured out (maybe you will ?) how to make the <code>namespace::key</code> syntax work for the macros, so just use <code>namespace.key</code>.</p>
</li>
<li>
<p><code>i18n-ally.sourceLanguage</code> (en): The primary key of the project, so I suggest putting the default locale for the value.</p>
</li>
<li>
<p><code>i18n-ally.displayLanguage</code> (en): The locale that the overlay uses.</p>
</li>
</ul>
<p>You can find other settings that could interest you in the <a href="https://github.com/lokalise/i18n-ally/wiki/Configurations">official doc</a>, with more information about the settings mentioned above, along with their default values.</p>
<h2 id="other-features"><a class="header" href="#other-features">Other features</a></h2>
<p>This extension offers some other interesting features that could interest you. I would suggest you take a look at their <a href="https://github.com/lokalise/i18n-ally/wiki">wiki</a> for more information.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
